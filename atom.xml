<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blackfish-wu.github.io/</id>
    <title>黑鱼的池塘</title>
    <updated>2020-03-29T15:50:57.240Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blackfish-wu.github.io/"/>
    <link rel="self" href="https://blackfish-wu.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blackfish-wu.github.io/images/avatar.png</logo>
    <icon>https://blackfish-wu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 黑鱼的池塘</rights>
    <entry>
        <title type="html"><![CDATA[面试题汇总]]></title>
        <id>https://blackfish-wu.github.io/post/mian-shi-ti-hui-zong/</id>
        <link href="https://blackfish-wu.github.io/post/mian-shi-ti-hui-zong/">
        </link>
        <updated>2020-03-28T16:00:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="tcpip">TCP/IP</h3>
<p>《计算机网络原理：自顶向下方法》《TCP/IP详解卷1》《图解TCP/IP》《图解HTTP》</p>
<ol>
<li>TCP和UDP的区别和优缺点？<br>
<a href="https://blog.csdn.net/xiaobangkuaipao/article/details/76793702">参考</a></li>
<li>三次握手四次挥手的过程</li>
<li>能不能两次握手</li>
<li>能不能三次挥手</li>
<li>如何保证可靠性<br>
<a href="https://blog.csdn.net/guanghuichenshao/article/details/81916277">2-5参考</a></li>
<li>TCP/IP有几层？每一层的作用？MAC地址在哪层？</li>
<li>有什么应用层协议</li>
<li>IPv4、IPv6</li>
<li>ARP协议</li>
<li>char*和char[10]的sizeof</li>
</ol>
<h3 id="算法">算法</h3>
<ol>
<li>数组与链表的区别</li>
<li>二分查找过程</li>
<li>二叉树遍历方式，后序过程</li>
<li>快排过程</li>
<li>二叉树先序遍历和后序遍历结果相同是什么二叉树</li>
<li>双向链表节点删除</li>
<li>单链表给两个指针怎么检验是否有环</li>
<li>堆排序为啥不稳定和建堆时间</li>
</ol>
<h3 id="java">Java</h3>
<ol>
<li>面向对象的设计要素</li>
<li>Java的基本变量有哪些？类型占用字节？</li>
<li>构造函数能被重写吗？能被重载吗？子类的super是重写吗？</li>
<li>List和Set区别是什么？Set为什么能去重？</li>
<li>HashMap底层原理：bucket扩容？k冲突了怎么办？</li>
<li>Volatile用过吗？有什么作用？</li>
<li>接口和抽象类的区别有哪些？能被实例化吗？里面变量有什么不同吗？方法有什么不同？</li>
<li>线程的创建方式有哪几种？创建方法说下？内存模型中线程私有的有哪些？</li>
<li>String abc = new Stirng(&quot;111&quot;)，新建了几个对象？abc指向哪？</li>
<li>对象和类的差异</li>
<li>全局变量和局部变量的存储位置</li>
<li>malloc内存分配的位置</li>
<li>strlen和sizeof</li>
<li>引用和指针</li>
<li>常用设计模式</li>
<li>虚函数和接口的差异</li>
<li>结构体内存对齐</li>
<li>多态了解</li>
<li>JVM类加载机制</li>
</ol>
<h3 id="操作系统">操作系统</h3>
<p>《深入理解计算机系统》 《Linux内核设计与实现》《深入理解linux内核》《Linux高性能服务器编程》</p>
<ol>
<li>进程间通讯用什么</li>
<li>虚拟机内存机制</li>
<li>进程阻塞是怎么做到的</li>
<li>多线程是什么</li>
<li>有哪些锁分别解释一下</li>
<li>缓存的作用以及缓存替换算法</li>
<li>线程的实现方式</li>
<li>虚拟文件系统</li>
<li>进程和线程之间的区别</li>
</ol>
<h3 id="数据库">数据库</h3>
<p>《数据库原理，编程与性能》《MySQL必知必会》《Redis设计与实现》</p>
<h4 id="数据库-2">数据库</h4>
<ol>
<li>索引：B树、B+树底层结构，索引失效条件</li>
<li>sql语法</li>
<li>关系型数据库三范式</li>
<li>存储引擎：InnoDB和MyISAM对比</li>
<li>数据库的锁：行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁等等</li>
<li>数据库隔离级别：脏读、不可重复读、幻读</li>
<li>事务的ACID理论</li>
<li>查询优化：explain，慢查询，show profile</li>
<li>分布式：分库分表，读写分离</li>
</ol>
<h4 id="redis相关">Redis相关</h4>
<ol>
<li>Redis 特点</li>
<li>Redis 底层数据结构：跳表，字典</li>
<li>数据淘汰策略</li>
<li>持久化方式：AOF，RDB</li>
<li>哨兵模式</li>
<li>集群同步方式</li>
</ol>
<h3 id="手撕代码">手撕代码</h3>
<ol>
<li>Leetcode石头碰撞问题</li>
<li>将一整数分别转换成对应的二进制、八进制和十六进制形式</li>
<li>将两个分数进行相加并化简成最精简的形式，输入的分数形式为&quot;a / b&quot;(除号两边有空格），a和b为正整数。<a href="https://www.nowcoder.com/discuss/391425?type=post&amp;order=time&amp;pos=&amp;page=1">题目</a></li>
<li>给一个数组找两个数加起来等于给定数</li>
<li>字符串最大连续子串</li>
<li>删除相邻的重复字符。例：acccaef输出为acaef，accaef输出为ef</li>
<li>字符串解码。例：3[a]2[c]输出为aaaccc，3[a2[c]]输出为accaccacc</li>
<li>链表节点初始化</li>
<li>int型数字反向输出(注意溢出问题)</li>
<li>完整实现一个双向链表</li>
<li>用数组实现深度为100的消息队列，入队出队函数</li>
</ol>
<h3 id="机考">机考</h3>
<ol>
<li>方阵旋转</li>
<li>分礼物</li>
<li>编辑距离</li>
</ol>
<h3 id="项目">项目</h3>
<ol>
<li>需求分析</li>
<li>并发访问的处理</li>
<li>UML有哪些模型</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP协议——ICMP]]></title>
        <id>https://blackfish-wu.github.io/post/tcpip-xie-yi-icmp/</id>
        <link href="https://blackfish-wu.github.io/post/tcpip-xie-yi-icmp/">
        </link>
        <updated>2020-03-23T02:37:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-引言">1 引言</h3>
<ul>
<li>ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。</li>
<li>ICMP报文通常被IP层或更高层协议（TCP或UDP）使用。</li>
<li>ICMP报文是在IP数据报内部，在IP数据报的数据部分。<br>
<img src="https://blackfish-wu.github.io//post-images/1584931223410.png" alt="ICMP报文" loading="lazy"></li>
<li>ICMP的正式规范参见RFC 792</li>
<li>ICMP的格式：
<ul>
<li>类型字段有15个值，以描述特定类型的ICMP报文。</li>
<li>代码字段用于某些ICMP报文，用以进一步描述不同的条件。</li>
<li><strong>检验和字段覆盖整个ICMP报文</strong>。使用的算法与IP首部检验和算法相同。<br>
<img src="https://blackfish-wu.github.io//post-images/1585137316500.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>不能产生ICMP差错报文的情况：
<ul>
<li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址或多播地址的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片。</li>
<li>源地址不是单个主机的数据报。源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ul>
</li>
</ul>
<h3 id="2-icmp报文类型">2 ICMP报文类型</h3>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584932928023.png" alt="ICMP报文类型" loading="lazy"></figure>
<ul>
<li>不同类型由报文中的类型字段和代码字段来共同决定。</li>
<li>上图中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。区分的原因是有时需要对ICMP差错报文进行特殊处理，例如在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文。</li>
<li>当发送一份ICMP差错报文时，报文始终包含<strong>产生ICMP差错报文的IP首部和IP数据报的前8个字节</strong>。这样，接收ICMP差错报文的模块就会把它与某个特定的协议和用户进程联系起来。
<ul>
<li>对于其他类型的ICMP<strong>查询</strong>报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。</li>
</ul>
</li>
</ul>
<h3 id="3-ping">3 Ping</h3>
<h4 id="31-ping程序">3.1 Ping程序</h4>
<ul>
<li>我们称发送回显请求的ping程序为客户，而称被ping的主机为服务器。</li>
<li>大多数的TCP/IP实现都在内核中直接支持Ping服务器<br>
<img src="https://blackfish-wu.github.io//post-images/1584967740554.png" alt="回显请求和回显应答报文" loading="lazy"></li>
<li>回显请求和回显应答报文格式如上所示，Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。</li>
<li>序列号从0开始，每发送一次新的回显请求就加1。</li>
<li>ping程序通过在ICMP报文数据中存放发送请求的时间值来计算往返时间。当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间。</li>
</ul>
<h4 id="32-记录路由">3.2 记录路由</h4>
<ul>
<li>记录路由是一个在IP首部设定RR选项的ICMP回显请求报文，每个处理该数据报的路由器都把它的IP<strong>出口</strong>地址放入选项字段中。当数据报到达目的端时，IP地址清单应该复制到ICMP回显应答中，这样返回途中所经过的路由器地址也被加入清单中。</li>
<li>缺陷：
<ul>
<li>不是所有路由都支持该选项功能</li>
<li>P首部中只有有限的空间来存放IP地址。由于IP首部固定长度为20字节， RR选项用去3个字节，这样只剩下37个字节来存放IP地址清单，也就是说只能存放9个IP地址。</li>
</ul>
</li>
<li>IP数据报中的RR选项的一般格式：<br>
<img src="https://blackfish-wu.github.io//post-images/1585214305402.png" alt="" loading="lazy">
<ul>
<li>code是一个字节，指明IP选项的类型。对于RR选项来说，它的值为7。</li>
<li>len是RR选项总字节长度，在这种情况下为39（ping程序总是提供39字节的选项字段，最多可以记录9个IP地址，尽管可以为RR选项设置更小的长度）。</li>
<li>ptr称作指针字段，指向存放下一个IP地址的位置</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP 协议——ARP]]></title>
        <id>https://blackfish-wu.github.io/post/tcpip-xie-yi-arp/</id>
        <link href="https://blackfish-wu.github.io/post/tcpip-xie-yi-arp/">
        </link>
        <updated>2020-03-21T15:32:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-引言">1 引言</h3>
<h4 id="11-arp简介">1.1 ARP简介</h4>
<ul>
<li>ARP为IP地址到对应的硬件地址之间提供动态映射。</li>
<li>点对点链路不使用ARP，在设置链路时，网络设备已获得了链路两端的IP地址，不需要ARP协议来实现IP地址和不同网络硬件地址的动态映射。</li>
<li>地址解析协议是IPv4中必不可少的协议，但在IPv6中将不再存在地址解析协议。在IPv6中，地址解析协议的功能将由NDP（邻居发现协议，Neighbor Discovery Protocol）实现</li>
<li>IP数据报在选择路由后发起ARP请求</li>
</ul>
<h3 id="2-arp请求过程">2 ARP请求过程</h3>
<h4 id="21-过程">2.1 过程</h4>
<ol>
<li>IP数据报在发送时会进行路由选择，得到下一站路由器的IP地址。</li>
<li>根据路由IP地址，先前往ARP高速缓存中查找，如果存在，则该数据报开始传送。否则ARP会发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播。</li>
<li>目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。</li>
<li>收到ARP应答后，该IP数据报开始传送。</li>
<li>如果没收到ARP应答，则以递增时序的方式进行请求，在三次请求无应答后停止。</li>
</ol>
<h4 id="22-arp数据帧格式">2.2 ARP数据帧格式</h4>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584854074912.png" alt="" loading="lazy"></figure>
<ol>
<li>以太网首部中的帧类型值为0x0806，代表该请求为ARP请求</li>
<li>硬件类型字段表示硬件地址的类型。值为1时表示以太网地址。</li>
<li>协议类型字段表示要映射的协议地址类型。值为0x0800即表示IP地址。</li>
<li>硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。</li>
<li>操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）。</li>
<li>接下来的四个字段是发送端的硬件地址、发送端的协议地址（IP地址）、目的端的硬件地址和目的端的协议地址。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP 协议——IP：网际协议]]></title>
        <id>https://blackfish-wu.github.io/post/tcpip-xie-yi-ipwang-ji-xie-yi/</id>
        <link href="https://blackfish-wu.github.io/post/tcpip-xie-yi-ipwang-ji-xie-yi/">
        </link>
        <updated>2020-03-20T09:51:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-引言">1 引言</h3>
<ul>
<li>IP是TCP/IP协议族中最为核心的协议。</li>
<li>所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</li>
<li><strong>不可靠性</strong>，指不能保证IP数据报能成功地到达目的地。任何要求的可靠性必须由上层来提供（如TCP）。</li>
<li><strong>无连接性</strong>，指是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。IP数据报可以不按发送顺序接收。</li>
<li>RFC 791是IP的正式规范文件。</li>
</ul>
<h3 id="2-ip首部">2 IP首部</h3>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584707964621.png" alt="IP数据报格式及首部中的各字段" loading="lazy"></figure>
<ul>
<li>数据报格式如上图，阅读顺序是从左到右，从上到下</li>
<li>前20个字节加上选项部分为IP首部</li>
<li>格式：
<ol>
<li>协议版本号，ipv4时值为4，ipv6值为6</li>
<li>首部长度，是指IP首部所占的字节数除以4的数量（单位：32bit），取值为5-15，即最少20字节，最大60字节。</li>
<li>服务类型，长度为8 bit，其中3 bit为优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位但必须置0。其中，TOS子字段分别表示最小时延、最大吞吐量、最高可靠性和最小费用。TOS子字段只能将其中一个置为1，当都为0时意味着是一般服务。RFC 1349更详细地描述了TOS的特征。</li>
<li>总长度，指整个IP数据报的长度，以字节为单位。由于该字段长16比特，所以IP数据报最大可达65535字节。当数据报被分片后，每个片的总长度值要改为该片的长度值。</li>
<li>标识字段，唯一地标识主机发送的每一份数据报，通常每发送一份报文它的值就会加1。</li>
<li>标志字段，标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1。标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。当需要进行分片但设置了不分片比特时，把数据报丢弃并发送一个ICMP差错报文。</li>
<li>片偏移字段，指的是该片偏移原始数据报开始处的位置。</li>
<li>TTL字段，生存时间字段设置了数据报可以经过的最多路由器数，指定了数据报的生存时间。每经过一个处理它的主机，它的值就减去1，当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>
<li>协议字段，根据它可以识别是哪个协议向IP传送数据。，1表示为ICMP协议， 2表示为IGMP协议， 6表示为TCP协议， 17表示为UDP协议。</li>
<li>首部检验和，检验数据报在传输过程中是否出现差错。将首部每16个bit视为一个二进制表示的数，按每1个bit进行反码求和后，将结果存放在首部校验和字段中。接收方接收后进行反码求和，结果应该全为1，否则丢弃该收到的数据报，但不生成差错报文。</li>
<li>源IP地址和目标IP地址</li>
<li>任选项，是数据报中的一个可变长的可选信息。如安全和处理限制，记录路径等等，很少被使用。选项字段一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节。</li>
</ol>
</li>
</ul>
<h3 id="3-路由选择">3 路由选择</h3>
<h4 id="31-路由表">3.1 路由表</h4>
<ol>
<li>目的IP地址。它既可以是一个完整的主机地址，也可以是一个网络地址。</li>
<li>下一站路由器的IP地址，或者有直接连接的网络IP地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。</li>
<li>标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。</li>
<li>为数据报的传输指定一个网络接口。</li>
</ol>
<h4 id="32-路由选择">3.2 路由选择</h4>
<ol>
<li>搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li>
<li>搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。</li>
<li>搜索路由表，寻找标为“默认（default）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。</li>
<li>如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。</li>
</ol>
<h3 id="4-子网寻址和子网掩码">4 子网寻址和子网掩码</h3>
<h4 id="41-子网寻址">4.1 子网寻址</h4>
<ul>
<li>子网，是指从大网络细分的子网络。因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{24}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{16}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>（全1和全0的主机地址无效）。在InterNIC获得某类I P网络号后，就由当地的系统管理员来进行分配，由他（或她）来决定是否建立子网，以及分配多少比特给子网号和主机号。</li>
<li>大多数的子网例子都是B类地址。其实，子网还可用于C类地址，只是它可用的比特数较少而已。大多数A类地址都是进行子网划分的。</li>
</ul>
<h3 id="42-子网掩码">4.2 子网掩码</h3>
<ul>
<li>子网掩码用来指明一个IP地址的哪些位标识的是主机的网络号和子网号，以及哪些位标识的是主机号。</li>
<li>子网掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</li>
<li>IP地址一般以点分十进制方法表示，但是子网掩码却经常用十六进制来表示。</li>
<li>给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：(1)本子网上的主机；(2)本网络中其他子网中的主机；(3)其他网络上的主机。</li>
<li>如果知道本机的IP地址，那么就知道它是否为A类、B类或C类地址(从IP地址的高位可以得知)，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。</li>
</ul>
<h3 id="5-特殊的ip地址">5 特殊的IP地址</h3>
<figure data-type="image" tabindex="2"><img src="https://blackfish-wu.github.io//post-images/1584800170291.png" alt="" loading="lazy"></figure>
<ul>
<li>上图表示7个特殊的IP地址，0表示所有的比特位全为0；- 1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。</li>
<li>表的头两项是特殊的源地址，中间项是特殊的环回地址，最后四项是广播地址。</li>
<li>表中的头两项，网络号为0，如主机使用BOOTP协议确定本机I P地址时只能作为初始化过程中的源地址出现。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP 协议——链路层]]></title>
        <id>https://blackfish-wu.github.io/post/tcpip-xie-yi-lian-lu-ceng/</id>
        <link href="https://blackfish-wu.github.io/post/tcpip-xie-yi-lian-lu-ceng/">
        </link>
        <updated>2020-03-19T08:56:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-引言">1 引言</h3>
<ul>
<li>在TCP/IP协议族中，链路层主要有三个目的：
<ol>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答；</li>
<li>为RARP发送RARP请求和接收RARP应答</li>
</ol>
</li>
</ul>
<h3 id="2-以太网和ieee-802封装">2 以太网和IEEE 802封装</h3>
<h4 id="21-以太网">2.1 以太网</h4>
<ul>
<li>以太网是当今TCP/IP采用的主要的局域网技术，采用带冲突检测的载波侦听多路接入方法（CSMA/CD）</li>
<li>速率为10Mb/s，地址为48bit。</li>
<li>数据报封装在RFC 894中定义。</li>
<li>封装格式中，目标地址和源地址之后为2字节的“类型”字段，该字段定义了后续数据的类型。</li>
<li>类型字段之后就是数据，最少要有46字节，在不足的空间必须插入填充（pad）字节。</li>
<li>最后有4字节的CRC检验码，用于帧内后续字节差错的循环冗余码检验。</li>
</ul>
<h4 id="22-ieee-802">2.2 IEEE 802</h4>
<ul>
<li>IEEE 802是对IEEE公布的的标准集，其中802.3针对整个CSMA/CD网络，802.4针对令牌总线网络，802.5针对令牌环网路。</li>
<li>802.3允许使用16bit的地址，但一般是48bit。</li>
<li>数据报封装在RFC 1042中定义。</li>
<li>封装格式中，目标地址和源地址之后为2字节的“长度”字段，该字段指它后续数据的字节长度，但不包括CRC检验码。“类型”字段则由后续的子网接入协议（Sub-network Access Protocol, SNAP）的首部给出。802定义的有效长度值与以太网的有效类型值均不相同，通过该值可以区分两种帧格式。</li>
<li>长度字段之后是3字节的802.2 LLC和5字节的802.2 SNAP。其中，LLC包含目的服务访问点（DSAP）、源服务访问点和Ctrl字段，均为一个字节。SNAP包含3字节的org code和两个字节的“类型“字段。</li>
<li>数据部分至少38字节，在不足的空间必须插入填充（pad）字节。</li>
<li>最后有4字节的CRC检验码。<br>
<img src="https://blackfish-wu.github.io//post-images/1584623667338.png" alt="802与以太网的封装格式" loading="lazy"></li>
</ul>
<h4 id="23-尾部封装">2.3 尾部封装</h4>
<ul>
<li>是一个早期BSD系统在DEC VA X机上运行时的试验格式，它通过调整IP数据报中字段的次序来提高性能。</li>
<li>数据报封装在RFC 893中定义。</li>
<li>尾部封装已遭到反对。</li>
</ul>
<h4 id="24-以太网主机需求">2.4 以太网主机需求</h4>
<ol>
<li>必须能发送和接收采用RFC 894（以太网）封装格式的分组。</li>
<li>必须能接收与RFC 894混合的RFC 1042（IEEE 802）封装格式的分组。</li>
<li>也许能够发送采用RFC 1042格式封装的分组。发送的分组必须是可以设置的，而且默认条件下必须是RFC 894分组。</li>
</ol>
<h3 id="3-slip">3 SLIP</h3>
<h4 id="31-串行线路ip介绍">3.1 串行线路IP介绍</h4>
<ul>
<li>SLIP的全称是Serial Line IP，是一种广泛使用在串行线路上的协议，对IP数据报以简单形式进行封装。</li>
<li>数据报封装在RFC 1055中定义。</li>
<li>封装格式：
<ol>
<li>IP数据报以一个称作END（0xc0）的特殊字符开始和结束。</li>
<li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符。</li>
<li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。<br>
<img src="https://blackfish-wu.github.io//post-images/1584624111155.png" alt="SLIP报文的封装" loading="lazy"></li>
</ol>
</li>
<li>缺陷：
<ol>
<li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li>
<li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和。如果报文被线路噪声影响而发生错误，只能通过上层协议来发现。因此上层协议提供某种形式的CRC就显得很重要。</li>
</ol>
</li>
</ul>
<h4 id="32-压缩的slip">3.2 压缩的SLIP</h4>
<ul>
<li>由于串行线路的速率通常较低（ 19200 b/s或更低），而且通信经常是交互式的（如Telnet和Rlogin，二者都使用TCP），因此在SLIP线路上有许多小的TCP分组进行交换。为了传送1个字节的数据需要20个字节的IP首部和2 0个字节的TCP首部，总数超过40个字节。CSLIP（即压缩SLIP）的新协议就是为了解决SLIP性能上的缺陷。</li>
<li>在RFC 1144中被详细描述</li>
<li>CSLIP一般能把上面的40个字节压缩到3或5个字节。</li>
<li>现在大多数的SLIP产品都支持CSLIP。</li>
</ul>
<h3 id="4-ppp点对点协议">4 PPP：点对点协议</h3>
<h4 id="41-协议内容">4.1 协议内容</h4>
<p>RFC 1548描述了报文封装的方法和链路控制协议。RFC 1332描述了针对IP的网络控制协议。</p>
<ol>
<li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。</li>
<li>建立、配置及测试数据链路的链路控制协议（ LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li>
<li>针对不同网络层协议的网络控制协议（ NCP：Network Control Protocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。</li>
</ol>
<h4 id="42-数据帧格式">4.2 数据帧格式</h4>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584628171306.png" alt="PPP数据帧的格式" loading="lazy"></figure>
<ul>
<li>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</li>
<li>接下来是协议字段，类似于以太网中类型字段的功能。当它的值为0x0021时，表示信息字段是一个IP数据报；值为0xc021时，表示信息字段是链路控制数据；值为0x8021时，表示信息字段是网络控制数据。</li>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>转义：当遇到字符0x7e时，需连续传送两个字符： 0x7d和0x5e，以实现标志字符的转义。当遇到转义字符0x7d时，需连续传送两个字符： 0x7d和0x5d，以实现转义字符的转义。默认情况下，如果字符的值小于0x20，也需要转义以规避对控制字符的特殊转义。</li>
</ul>
<h4 id="43-优点">4.3 优点</h4>
<ul>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。</li>
</ul>
<h3 id="5-环回接口">5 环回接口</h3>
<ul>
<li>大多数的产品都支持环回接口（ Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。</li>
<li>A类网络号127就是为环回接口预留的。</li>
<li>一个传给环回接口的IP数据报不能在任何网络上出现。<br>
<img src="https://blackfish-wu.github.io//post-images/1584630544592.png" alt="环回接口处理IP数据报的过程" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP 协议——概述]]></title>
        <id>https://blackfish-wu.github.io/post/di-yi-tian/</id>
        <link href="https://blackfish-wu.github.io/post/di-yi-tian/">
        </link>
        <updated>2020-03-18T09:09:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-分层">1 分层</h3>
<h4 id="11-概述">1.1 概述</h4>
<p>TCP/IP通常被认为是一个四层协议系统</p>
<ol>
<li>应用层，负责处理特定的应用程序细节。通用的应用程序：Telnet 远程登录；FTP文件传输协议；SMTP简单邮件传送协议；SNMP 简单网络管理协议。</li>
<li>运输层，主要为两台主机上的应用程序提供<strong>端到端</strong>的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。而另一方面， UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。</li>
<li>网络层，有时也称作互联网层，提供<strong>点到点</strong>的服务，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协（Internet组管理协议）。</li>
<li>链路层，有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。<br>
<img src="https://blackfish-wu.github.io//post-images/1584584791065.png" alt="" loading="lazy"></li>
</ol>
<h4 id="12-分层协议">1.2  分层协议</h4>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584584901048.png" alt="" loading="lazy"></figure>
<ul>
<li>运输层
<ul>
<li>TCP（传输控制协议）：TCP使用不可靠的IP服务，但它却提供一种可靠的运输层服务。</li>
<li>UDP（用户数据协议）：UDP是不可靠的，能为应用程序发送和接收数据报。一个数据报是指从发送方传输到接收方的一个信息单元。</li>
</ul>
</li>
<li>网络层
<ul>
<li>IP是网络层上的主要协议，同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。</li>
<li>ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</li>
<li>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</li>
</ul>
</li>
<li>链路层
<ul>
<li>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
</ul>
</li>
</ul>
<h3 id="2-互联网地址和域名系统">2 互联网地址和域名系统</h3>
<h4 id="21-互联网地址">2.1 互联网地址</h4>
<figure data-type="image" tabindex="2"><img src="https://blackfish-wu.github.io//post-images/1584588205455.png" alt="五类互联网地址" loading="lazy"></figure>
<ul>
<li>长度为32bit，通常写成四个十进制的数，每个数为1个字节，范围从0-255</li>
<li>区分各类地址的最简单方法是看它的第一个十进制整数，下图列出了各类地址的起止范围。<br>
<img src="https://blackfish-wu.github.io//post-images/1584602058553.png" alt="各类IP地址的范围" loading="lazy"></li>
<li>多接口主机具有多个IP地址，其中每个接口都对应一个IP地址。</li>
<li>互联网上的每个接口必须有一个唯一的IP地址 为接入互联网的网络分配IP地址的机构叫互联网信息中心，称为InterNIC。InterNIC只分配网络号。主机号的分配由系统管理员来负责。</li>
<li>有三类IP地址：单播地址（目的为单个主机）、广播地址（目的端为给定网络上的所有主机）以及多播地址（目的端为同一组内的所有主机）</li>
</ul>
<h4 id="22-域名系统">2.2 域名系统</h4>
<ul>
<li>尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</li>
</ul>
<h3 id="3-封装和分用">3 封装和分用</h3>
<h4 id="31-封装">3.1 封装</h4>
<ul>
<li>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）</li>
<li>TCP传给IP的数据单元称作TCP报文段或简称为TCP段</li>
<li>IP传给网络接口层的数据单元称作IP数据报</li>
<li>通过以太网传输的比特流称作帧(Frame)<br>
<img src="https://blackfish-wu.github.io//post-images/1584602596706.png" alt="" loading="lazy"></li>
<li>UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作UDP数据报（UDP datagram），而且UDP的首部长为8字节。</li>
</ul>
<h4 id="32-分用">3.2 分用</h4>
<ul>
<li>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（ Demultiplexing）<br>
<img src="https://blackfish-wu.github.io//post-images/1584603217689.png" alt="以太网数据帧的分用过程" loading="lazy"></li>
</ul>
<h3 id="4-客户-服务器模型">4 客户-服务器模型</h3>
<ul>
<li>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服<br>
务器为客户提供一些特定的服务。可以将这种服务分为两种类型：重复型或并发型。</li>
<li>一般来说， TCP服务器是并发的，而UDP服务器是重复的</li>
</ul>
<h4 id="41-重复型">4.1 重复型</h4>
<ul>
<li>步骤如下：
<ol>
<li>等待一个客户请求的到来。</li>
<li>处理客户请求。</li>
<li>发送响应给发送请求的客户。</li>
<li>返回第1步。</li>
</ol>
</li>
<li>重复型服务器的问题主要在第2步，处理用户请求时无法为其他客户机提供服务。</li>
</ul>
<h4 id="42-并发型">4.2 并发型</h4>
<ul>
<li>步骤
<ol>
<li>等待一个客户请求的到来。</li>
<li>启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。</li>
<li>返回第1步。</li>
</ol>
</li>
<li>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。</li>
</ul>
<h3 id="5-端口号">5 端口号</h3>
<ul>
<li>TCP和UDP采用16 bit的端口号来识别应用程序。</li>
<li>服务器一般都是通过知名端口号来识别的。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。</li>
<li>客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以。客户端口号又称作<strong>临时端口号</strong>（即存在时间很短暂）。大多数TCP/IP实现给临时端口分配1024～5000之间的端口号。</li>
</ul>
<h3 id="6-标准化过程">6 标准化过程</h3>
<h4 id="61-标准化组织">6.1 标准化组织</h4>
<ol>
<li>Internet协会（ISOC，Internet Society）是一个推动、支持和促进Internet不断增长和发展的专业组织，它把Internet作为全球研究通信的基础设施。</li>
<li>Internet体系结构委员会（IAB，Internet Architecture Board）是一个技术监督和协调的机 构。它由国际上来自不同专业的15个志愿者组成，其职能是负责Internet标准的最后编辑和技术审核。IAB隶属于ISOC。</li>
<li>Internet工程专门小组（IETF，Internet Engineering Task Force）是一个面向近期标准的组织，它分为9个领域（应用、寻径和寻址、安全等等）。IETF开发成为Internet标准的规范。为帮助IETF主席，又成立了Internet工程指导小组（IESG, Internet Engineering Steering Group）。隶属于IAB。</li>
<li>Internet研究专门小组（IRIF，Internet Research Task Force）主要对长远的项目进行研究。隶属于IAB。</li>
</ol>
<h4 id="62-标准化文档">6.2 标准化文档</h4>
<ul>
<li>所有关于Internet的正式标准都以<strong>RFC</strong>（Request for Comment）文档出版。</li>
<li>大量的RFC并不是正式的标准，出版的目的只是为了提供信息。</li>
<li>RFC的篇幅从1页到200页不等。每一项都用一个数字来标识，如RFC1122，数字越大说明RFC的内容越新。</li>
</ul>
<h4 id="63-实现">6.3 实现</h4>
<ul>
<li>既成事实标准的TCP/IP软件实现来自于位于伯克利的加利福尼亚大学的计算机系统研究小组。</li>
<li>从历史上看，软件是随同4.x BSD系统（Berkeley Software Distribution）的网络版一起发布的。</li>
</ul>
<h4 id="64-接口">6.4 接口</h4>
<ul>
<li>使用TCP/IP协议的应用程序通常采用两种应用编程接口（AP I）：socket和TLI（运输层接口：Transport Layer Interface）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构——排序]]></title>
        <id>https://blackfish-wu.github.io/post/shu-ju-jie-gou-pai-xu/</id>
        <link href="https://blackfish-wu.github.io/post/shu-ju-jie-gou-pai-xu/">
        </link>
        <updated>2020-01-04T02:49:42.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1581253777738.png" alt="" loading="lazy"></figure>
<h3 id="1-冒泡排序">1 冒泡排序</h3>
<p>时间复杂度：</p>
<ul>
<li>最好情况：顺序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>最坏情况：逆序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>优点：</p>
<ul>
<li>适用于链表结构的排序</li>
<li>稳定</li>
</ul>
<p>缺点：</p>
<ul>
<li>时间复杂度高</li>
</ul>
<pre><code class="language-C">void Bubble_Sort(ElementType A[], int N){
    int flag;
    for(int i=N-1;i&gt;0;i--){
        flag = 0;
        for(int j=0;j&lt;i;j++){
            if(A[j]&gt;A[j+1]){
                swap(A[j], A[j+1]);
                flag = 1;
            }
        }
        if(flag==0) break;
    }
}
</code></pre>
<h3 id="2-插入排序">2 插入排序</h3>
<p>思路：定义数组中左侧位置是一个已排好序的数组，其他部分为未排序部分，每次从未排序部分取出一个数，跟左侧进行对比<br>
<img src="https://blackfish-wu.github.io//post-images/1578283315531.gif" alt="" loading="lazy"><br>
时间复杂度：</p>
<ul>
<li>最好情况：顺序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>最坏情况：逆序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>对于下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>&gt;</mo><mi>A</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[i]&gt;A[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，则称（i，j）是一堆<strong>逆序对</strong>。</li>
<li>当逆序对数量为n时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mo>(</mo><mi>N</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=(N+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Insertion_Sort(ElementType A[], int N){
    for(int i=1;i&lt;N;i++){
        num = A[i];
        for(int j=i;j&gt;=0&amp;&amp;A[j-1]&gt;num;j++)
            A[j] = A[j-1];
        A[j] = num;
    }
}
</code></pre>
<h3 id="3-希尔排序">3 希尔排序</h3>
<p>思路：跟插入排序相似，克服了插入排序每次只交换相邻两元素的缺点。<br>
时间复杂度：</p>
<ul>
<li>原始希尔排序：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>M</mi></msub><mo>=</mo><mo>[</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>]</mo><mo separator="true">,</mo><msub><mi>D</mi><mi>k</mi></msub><mo>=</mo><mo>[</mo><msub><mi>D</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">/</mi><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">D_M=[N/2], D_k=[D_{k+1}/2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span><span class="mclose">]</span></span></span></span>，此时最坏情况：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T=\Theta(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>Hibbard增量序列（相邻元素互质）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>k</mi></msub><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D_k=2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，此时最坏情况：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>N</mi><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(N^{3/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，猜想：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>N</mi><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>4</mn></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T_{avg}=O(N^{5/4})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">/</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>Sedgewick增量序列：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>19</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>109</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">D=\{1,5,19,41,109,...\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose">}</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>9</mn><mo>∗</mo><msup><mn>4</mn><mi>i</mi></msup><mo>−</mo><mn>9</mn><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D_i=9*4^i-9*2^i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><msup><mn>4</mn><mi>i</mi></msup><mo>−</mo><mn>3</mn><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D_i=4^i-3*2^i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。猜想：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>N</mi><mrow><mn>4</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup><mo>)</mo><mo separator="true">,</mo><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>N</mi><mrow><mn>7</mn><mi mathvariant="normal">/</mi><mn>6</mn></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T_{worst}=O(N^{4/3}), T_{avg}=O(N^{7/6})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.174108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">/</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mord mtight">/</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>缺点：</p>
<ul>
<li>不稳定</li>
</ul>
<pre><code class="language-C">void Shell_Sort(ElementType A[], int N){
    for(int D=N/2;N&gt;0;N/=2){
        for(int i=D;i&lt;N;i++){
            temp = A[i];
            for(int j=i;j&gt;=0&amp;&amp;A[j-D]&gt;temp;j-=D)
                A[j] = A[j-D];
            A[j] = temp;
        }
    }
}
</code></pre>
<h3 id="4-选择排序">4 选择排序</h3>
<p>时间复杂度：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T=\Theta(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Selection_Sort(ElementType A[], int N){
    for(int i=0;i&lt;N;i++){
        MinPostion = ScanForMin(A, i, N-1);
        Swap(A[i], A[MinPosition]);
    }
}
</code></pre>
<h3 id="5-堆排序">5 堆排序</h3>
<ul>
<li>算法1<br>
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>N</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Heap_Sort(ElementType A[], int N){
    BuildHeap(A); 
    for(i=0;i&lt;N;i++)
        Temp[i] = DeleteMin(A);
    for(i=0;i&lt;N;i++)
        A[i] = Temp[i];
}
</code></pre>
<ul>
<li>算法2<br>
思路：将待排序序列构造成一个最大堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。令堆大小减1，然后将剩余n-1个元素重新构造成一个最大堆，这样会得到n个元素的次小值，根节点与末尾元素交换。<br>
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>N</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Heap_Sort(ElementType A[], int N){
    for(i=N/2-1;i&gt;=0i--;)
        PercDown(A, i, N);
    for(i=N-1;i&gt;=0;i--){
        Swap(A, 0, i);
        PercDown(A, 0, i);
    }
}
</code></pre>
<h3 id="6-归并排序">6 归并排序</h3>
<p>时间复杂度（任何情况）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>N</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span><br>
稳定性：稳定</p>
<pre><code class="language-C">void Merge_Sort(ElementType A[], int N){
    ElementType *TmpA;
    TmpA = malloc(N*sizeof(ElementType));
    if(TmpA!=NULL){
        MSort(A, TmpA, 0, N-1);
        free(TmpA);
    }
}
void MSort(ElementType A[], ElementType TempA[], int L, int RightEnd){
    int Center;
    if( L &lt; RightEnd ){
        Center = (L+RightEnd)/2;
        MSort(A, TempA, L, Center);
        MSort(A, TempA, Center+1, RightEnd);
        Merge(A, TempA, L, Center+1, RightEnd);
    }
}
</code></pre>
<h3 id="7-快速排序">7 快速排序</h3>
<pre><code class="language-C">void Quick_Sort(ElementType A[], int N){

}

void Quicksort( ElementType A[], int Left, int Right){
    if( Cutoff &lt;= Right-Left ){
        Pivot  = Median3(A, Left, Right);
        i = Left;  j = Right - 1;
        for(;;){
            while(A[++i] &lt; Pivot){}
            while(A[--j] &gt; Pivot){}
            if(i&lt;j)
                Swap(A, i, j);
            else
                break;
        }
        Swap(A, i, Right);
        Quicksort(A, Left, i-1);
        Quicksort(A, i+1, Right);
    }
    else  /* 数据规模小用插入排序 */
        Insertion_Sort(A+Left, Right-Left+1);
}
</code></pre>
<h3 id="8-表排序">8 表排序</h3>
<p>适用于待排元素是一个庞大结构，移动元素的时间不能忽略不计的时候，表排序不移动元素，只移动元素指针。</p>
<h3 id="9-基数排序">9 基数排序</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构——图]]></title>
        <id>https://blackfish-wu.github.io/post/shu-ju-jie-gou-tu/</id>
        <link href="https://blackfish-wu.github.io/post/shu-ju-jie-gou-tu/">
        </link>
        <updated>2019-10-07T14:51:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-介绍">1 介绍</h2>
<h3 id="11-定义">1.1 定义</h3>
<ul>
<li>表示“多对多”的关系</li>
<li>包含：
<ol>
<li>一组顶点：通常用V(Vertex)表示顶点集合</li>
<li>一组边：通常用E(Edge)表示边的集合：无向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo><mo>∈</mo><mi>E</mi><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">(v,w)\in E, 其中 v,w\in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>；有向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v,w&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>表示从v到w的边；不考虑重边和自会路</li>
</ol>
</li>
</ul>
<h3 id="12-常见术语">1.2 常见术语</h3>
<ul>
<li>无向图：所有的边都没有方向的图</li>
<li>有向图：边是有方向的</li>
<li>网络：边带权重的图</li>
<li>度：从顶点发出的边数为“出度”，指向该点的边数为“入度”</li>
<li>连通：如果从V到W存在一条(无向)路径，则称V和W是连通的</li>
<li>路径：V到W的路径是一系列顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>W</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{V, v_1, v_2, ..., v_n, W\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mclose">}</span></span></span></span>的集合，其中任一对相邻的顶点间都有图的边。<strong>路径的长度</strong>是路径中的边数（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同，则称为<strong>简单路径</strong></li>
<li>回路：起点等于终点的路径</li>
<li>连通图：图中任意两顶点均连通</li>
<li>连通分量：无向图的<strong>极大</strong>连通子图，极大表示：①顶点数极大，再加上一个顶点就不连通了。②边数极大，包含子图中的所有顶点相连的所有边。</li>
<li>强连通：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的</li>
<li>强连通图：有向图中任意两个顶点均强连通</li>
<li>强连通分量：有向图中的极大强连通子图</li>
</ul>
<h3 id="13-图的表示">1.3 图的表示</h3>
<h4 id="131-邻接矩阵">1.3.1 邻接矩阵</h4>
<ol>
<li>邻接矩阵G[N][N]——N个顶点从0到N-1编号</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">若</mi><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mi mathvariant="normal">是</mi><mi>G</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">边</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">否</mi><mi mathvariant="normal">则</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">G[i][j]=\begin{cases} 1&amp; 若&lt;v_i,v_j&gt;是G中的边\\ 0&amp; 否则 \end{cases} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">G</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">边</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">则</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ol start="2">
<li>邻接矩阵的特点：
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li>
<li>方便计算任一顶点的“度”</li>
</ul>
</li>
<li>邻接矩阵的缺点：
<ul>
<li>浪费空间————存稀疏图（点很多而边很少）有大量无效元素，但存稠密图（特别是完全图）挺合算</li>
<li>浪费时间————统计稀疏图中一共有多少条边</li>
</ul>
</li>
</ol>
<h4 id="132-邻接表">1.3.2 邻接表</h4>
<ol>
<li>邻接表：G[N]为指针数组，数组的每个元素存放一行链表的头结点，只存非0元素<br>
<img src="https://blackfish-wu.github.io//post-images/1570503578069.png" alt="" loading="lazy"></li>
<li>邻接表的特点：
<ul>
<li>方便找任一顶点中的所有“邻接点”</li>
<li>节约稀疏图的空间（需要N个头指针+2E个结点，E为边数）</li>
<li>方便计算无向图的度和有向图的出度，但不方便计算有向图的入度</li>
</ul>
</li>
<li>邻接表的缺点
<ul>
<li>本身多了一个指针域，表示网络来说，多了一个权重域，所以仅适用于表达稀疏图</li>
<li>不方便计算有向图的入度（除非再构造一个“逆邻接表”）</li>
</ul>
</li>
</ol>
<h3 id="14-图的遍历">1.4 图的遍历</h3>
<h4 id="141-深度优先遍历depth-fisrt-searchdfs">1.4.1 深度优先遍历（Depth Fisrt Search，DFS）</h4>
<pre><code class="language-C">/* 伪代码 */
void DFS(Vertex V){
    visited[V] = true;
    for(V的每个邻接点W)
        if(!visited[W])
            DFS(W);
}
</code></pre>
<ul>
<li>用邻接表存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> (N为结点数，E为边数)</li>
<li>用邻接矩阵存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="142-广度优先遍历breadth-fisrt-searchbfs">1.4.2 广度优先遍历（Breadth Fisrt Search，BFS）</h4>
<pre><code class="language-C">/* 伪代码 */
void BFS(Vertex V){
    visited[V] = true;
    Enqueue(V, Q);
    while(!IsEmpty(Q)){
        V = Dequeue(Q);
        for(V的每个邻接点W){
            if(!visited[W]){
                visited[W] = true;
                Enqueue(V, Q);
            }
        }
    }
}
</code></pre>
<ul>
<li>用邻接表存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> (N为结点数，E为边数)</li>
<li>用邻接矩阵存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="2-最短路径">2 最短路径</h2>
<h3 id="21-定义">2.1 定义</h3>
<ul>
<li>最短路径：在网络中，求两个顶点间的所有路径中，边权值之和最小的那条路径就是这两点间的最短路径。</li>
<li>源点：求最短路径时的起点称之为源点</li>
<li>终点：求最短路径时的终点称之为终点</li>
<li>单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径</li>
<li>多源最短路径问题：求任意两顶点间的最短路径</li>
</ul>
<h3 id="22-方法">2.2 方法</h3>
<h4 id="221-无权图的单源最短路算法">2.2.1 无权图的单源最短路算法</h4>
<pre><code class="language-C">// T = O(|V|+|E|)
void Unweighted( Vertex S ){
    Enqueue(S, Q);
    while(!IsEmpty(Q)){
        V = Dequeue(Q);
        for(V的每个邻接点W){
            if(dist[W]==-1){
                dist[W] = dist[V]+1;
                path[W] = V;
                Enqueue(W, Q);
            }
        }
    }
}
</code></pre>
<h4 id="222-有权图的单源最短路算法dijkstra算法">2.2.2 有权图的单源最短路算法——Dijkstra算法</h4>
<ul>
<li>令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mi mathvariant="normal">源</mi><mi mathvariant="normal">点</mi><mi>s</mi><mo>+</mo><mi mathvariant="normal">已</mi><mi mathvariant="normal">经</mi><mi mathvariant="normal">确</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">短</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">顶</mi><mi mathvariant="normal">点</mi><msub><mi>v</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">S=\{源点s+已经确定了最短路径的顶点v_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord cjk_fallback">源</span><span class="mord cjk_fallback">点</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">短</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li>
<li>对任一未收录的顶点v，定义dist[V]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>s</mi><mo>→</mo><mo>(</mo><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>S</mi><mo>)</mo><mo>→</mo><mi>v</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{s\rightarrow (v_i \in S)\rightarrow v\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">}</span></span></span></span>的最小长度</li>
<li>真正的最短路径只经过S中的顶点</li>
<li>每次从未收录的顶点中选一个dist最小的收录（贪心）：如果采用遍历的方式获得dist最小，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|V|^2+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>；如果采用最小堆的方法建立和获得最小dist，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|V|log(|V|)+|E|log(|V|))=O(|E|log(|V|))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>增加一个v到S，可能影响另外一个w的dist值</li>
</ul>
<pre><code class="language-C">void Dijkstra(Vertex S){
    while(1){
        V = 未收录顶点中dist最小者;
        if(V不存在)
            break;
        collected[V] = true;
        for(V的每个邻接点W){
            if(collected[W] = false){
                if(dist[V]+E&lt;v,w&gt; &lt; dist[W]){
                    dist[W] = dist[V]+E&lt;v,w&gt;;
                    path[W] = V;
                }
            }
        }
    }
}
</code></pre>
<h4 id="223-多源最短路算法floyd算法">2.2.3 多源最短路算法——Floyd算法</h4>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mo>{</mo><mi>i</mi><mo>→</mo><mo>{</mo><mi>l</mi><mo>≤</mo><mi>k</mi><mo>}</mo><mo>→</mo><mi>j</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">D^k[i][j]=路径\{i \rightarrow \{l\le k\}\rightarrow j\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mopen">{</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mn>0</mn></msup><mo separator="true">,</mo><msup><mi>D</mi><mn>1</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>D</mi><mrow><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">D^0, D^1, ..., D^{|v|-1}[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mtight">∣</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>即给出了从0到|v|-1逐次加入顶点后i到j的最短距离矩阵</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>应为带权的邻接矩阵，对角线为0</li>
<li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>已经完成，递推到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">D^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>时：如果新加入的顶点k不影响<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>各个顶点彼此间最短路径，则不需要更新；反之，如果影响了，那么影响后的最短路径必然由两段最短路径组成，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">D^k[i][j]=D^{k-1}[i][k]+D^{k-1}[k][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Floyd(){
    for(i=0;i&lt;N;i++){
        for(j=0;j&lt;n;j++){
            D[i][j] = G[i][j];
            path[i][j] = -1;
        }
    }
    for(k=0;k&lt;N;k++)
        for(i=0;i&lt;N;i++){
            for(j=0;j&lt;n;j++)
                if(D[i][k]+D[k][j]&lt;D[i][j]){
                    D[i][j] = D[i][k]+D[k][j];
                    path[i][j] = k;
                }
            }
}
</code></pre>
<h2 id="3-最小生成树">3 最小生成树</h2>
<h3 id="31-定义">3.1 定义</h3>
<ul>
<li>是一棵无回路的树，|V|个顶点一定有|V|-1条边</li>
<li>包含了全部的顶点，|V|-1条边都在路里</li>
<li>|V|-1条边的权重和最小</li>
</ul>
<h3 id="32-方法">3.2 方法</h3>
<h4 id="321-prim算法">3.2.1 Prim算法</h4>
<pre><code class="language-C">void Prim(Vertex s){
    MST = {s};
    while(1){
        v = 未收录顶点中dist最小的;
        if(这样的V不存在)
            break;
        将V收录进MST: dist[v] = 0;
        for(v的每个邻接点W){
            if(W未被收录)
                if(E&lt;v,w&gt; &lt; dist[w]){
                    dist[W] = E&lt;v,w&gt;;
                }
        }
    }
}
</code></pre>
<h4 id="322-kruskal算法将森林合并成树">3.2.2 Kruskal算法——将森林合并成树</h4>
<ul>
<li>思路：从图中每次找到边权值最小的边，如果该边不构成回路，则加入到生成树集合；如果构成，删除掉该边</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|E|log(|E|))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Kruskal(Vertex s){
    MST = {};
    while(MST中的边不到|V|-1条&amp;&amp;E中还有边){
        e=E中权重最小的边；            /* 最小堆 */
        Delete(E, e); 
        if(e加入到MST没有构成最小回路)  /* 并查集 */
            e 加入到 MST;
    }
    if( MST中的边不到|V|-1条 )
        Error(&quot;生成树不存在&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OGC的Simple Features Access(ISO 19125)标准]]></title>
        <id>https://blackfish-wu.github.io/post/ogc-de-simple-features-accessiso-19125biao-zhun/</id>
        <link href="https://blackfish-wu.github.io/post/ogc-de-simple-features-accessiso-19125biao-zhun/">
        </link>
        <updated>2019-09-23T12:29:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-简介">1 简介</h2>
<p>OpenGIS定义的Simple Features Access（SFA， ISO 19125）标准的第二部分定义了包含了空间和非空间属性的要素集合的标准SQL模式。这里的要素集是指带地理属性的表。该标准主要包含以下4点：</p>
<ol>
<li>确立了一个表达要素的框架</li>
<li>确立了框架的一系列术语的定义</li>
<li>定义了一个用于定义几何属性的简单几何概述</li>
<li><strong>描述了一系列SQL几何类型及其对应的SQL函数</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构——树]]></title>
        <id>https://blackfish-wu.github.io/post/shu/</id>
        <link href="https://blackfish-wu.github.io/post/shu/">
        </link>
        <updated>2019-09-19T02:18:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-树的表示">1 树的表示</h2>
<h3 id="11-儿子兄弟表示法">1.1 儿子兄弟表示法</h3>
<p>结点设置两个指针域，一个指向儿子，一个指向右侧的第一个兄弟<br>
<img src="https://blackfish-wu.github.io//post-images/1568859566733.png" alt="" loading="lazy"></p>
<h2 id="2-二叉树">2 二叉树</h2>
<h3 id="21-定义">2.1 定义</h3>
<p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构，结点有左右之分。</p>
<h3 id="22-特殊二叉树">2.2 特殊二叉树</h3>
<ol>
<li>斜二叉树（Skewed Binary Tree）: 只有左子节点或只有右子节点的二叉树称为斜二叉树</li>
<li>满二叉树（Full Binary Tree）：又叫完美二叉树（Perfect Binary Tree）。除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。</li>
<li>完全二叉树（Compelete Binary Tree）：对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。</li>
</ol>
<h3 id="23-性质">2.3 性质</h3>
<ol>
<li>一个二叉树的第i层的最大结点数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{i-1}, i \geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>深度为k的二叉树最大结点数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1, k \geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>对于任何一颗非空二叉树T，假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示叶结点的个数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示度为2的结点个数，则两者满足关系<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0 = n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。推导：边总数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>−</mo><mn>1</mn><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s=n_0+n_1+n_2-1=n_1+2n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<h3 id="24-存储结构">2.4 存储结构</h3>
<h4 id="241-顺序存储结构">2.4.1 顺序存储结构</h4>
<ul>
<li>完全二叉树：按从上至下、从左至右顺序存储到数组。非根结点的父节点序号是[i/2]，结点的左孩子序号是2i，结点的右孩子序号是2i+1</li>
<li>一般二叉树：同样可以按照这种结构，但是会造成空间浪费<br>
<img src="https://blackfish-wu.github.io//post-images/1569569016795.png" alt="" loading="lazy"></li>
</ul>
<h4 id="242-链表存储结构">2.4.2 链表存储结构</h4>
<p>定义一个左指针、数据和右指针的结构体来存放结点</p>
<h3 id="25-遍历">2.5 遍历</h3>
<h4 id="251-递归遍历">2.5.1 递归遍历</h4>
<ol>
<li>先序遍历：（1）先访问节点；（2）先序遍历左子树；（3）先序遍历右子树</li>
</ol>
<pre><code class="language-C">void PreOrderTraversal( BinTree BT )
    if(BT){
        printf(&quot;%d&quot;, BT-&gt;Data);
        PreOrderTraversal( BT-&gt;Left );
        PreOrderTraversal( BT-&gt;Right );
    }
</code></pre>
<ol start="2">
<li>中序遍历：（1）先序遍历左子树；（2）访问根节点；（3）先序遍历右子树</li>
</ol>
<pre><code class="language-C">void InOrderTraversal( BinTree BT )
    if(BT){
        InOrderTraversal( BT-&gt;Left );
        printf(&quot;%d&quot;, BT-&gt;Data);
        InOrderTraversal( BT-&gt;Right );
    }
</code></pre>
<ol start="3">
<li>后序遍历：（1）先序遍历左子树；（2）先序遍历右子树；（3）访问根节点</li>
</ol>
<pre><code class="language-C">void PostOrderTraversal( BinTree BT )
    if(BT){
        PostOrderTraversal( BT-&gt;Left );
        PostOrderTraversal( BT-&gt;Right );
        printf(&quot;%d&quot;, BT-&gt;Data);
    }
</code></pre>
<h4 id="252-非递归遍历">2.5.2 非递归遍历</h4>
<ol>
<li>前序遍历：（1）访问并遍历左结点（2）从栈中取出结点；（3）访问右结点，回到（1）</li>
</ol>
<pre><code class="language-C">void PreOrderTraversal( BinTree BT ){
    BinTree T = BT;
    Stack S = CreateStack( MaxSize );
    while( T || !IsEmpty(S) ){
        while( T ){
            printf(&quot;%5d&quot;, T-&gt;Data);
            Push(S,T);
            T = T-&gt;Left;
        }
        while( !IsEmpty(S) ){
            T = Pop(S);
            T = T-&gt;Right;
        }
    }
}
</code></pre>
<ol start="2">
<li>中序遍历：（1）先遍历左子树，压入栈中，直至左子树为空；（2）从栈中取出一个结点，访问它；（3）讲该结点的右子树作为起始结点，回到（1）</li>
</ol>
<pre><code class="language-C">void InOrderTraversal( BinTree BT ){
    BinTree T = BT;
    Stack S = CreateStack( MaxSize );
    while( T || !IsEmpty(S) ){
        while( T ){
            Push(S,T);
            T = T-&gt;Left;
        }
        while( !IsEmpty(S) ){
            T = Pop(S);
            printf(&quot;%5d&quot;, T-&gt;Data);
            T = T-&gt;Right;
        }
    }
}
</code></pre>
<ol start="3">
<li>后序遍历：（1）当前结点左子树不为空且左孩子和右孩子没有被访问过的情况下，不断入栈左子树；（2）左子树访问结束，判断当前结点是否有右孩子且右孩子没有访问过的情况下，入栈右孩子，回到步骤（1）；（3）当最后一个右孩子被访问到时，开始出栈并访问该结点。</li>
</ol>
<pre><code class="language-C">void PostOrderTraversal( BinTree BT ){
    BinTree T = BT;
    Set Visited = CreateSet( MaxSize );
    Stack S = CreateStack( MaxSize );
    Push(Visited, T);
    Push(S, T);
    while(!IsEmpty(Visited)){
        // 查看栈顶的结点左右结点是否为空或左右结点是否都被访问过
        BinTree Node = findUnvisitedNode(Peak(S), Visited);
        if(Node==null){
            T = Pop(S);
            printf(&quot;%d&quot;, T-&gt;data);
        }else{
            Push(visited, Node);
            Push(S, Node);
        }
    }
}

BinTree findUnvisitedNode(BinTree Node, Set Visited){
    if (Node-&gt;left != null &amp;&amp; !Visited.contains(Node-&gt;left)) {
        return Node.left;
    } else if (Node-&gt;right != null &amp;&amp; !Visited.contains(Node-&gt;right))
        return Node-&gt;right;
    else
        return null;
}
</code></pre>
<h3 id="26-二叉搜索树">2.6 二叉搜索树</h3>
<h4 id="261-定义">2.6.1 定义</h4>
<p>二叉搜索树：一棵二叉树，可以为空，如果不为空，满足一下性质：</p>
<ol>
<li>非空左子树的所有键值小于根结点的键值。</li>
<li>非空右子树的所有键值大于根结点的键值。</li>
<li>左、右子树都是二叉搜索树。</li>
</ol>
<h4 id="261-操作函数">2.6.1 操作函数</h4>
<ol>
<li>Position Find(ElementType X, BinTree BST)：从二叉树BST中查找元素X，返回结点所在的地址</li>
</ol>
<pre><code class="language-C">// 递归版本
Position Find(ElementType X, BinTree BST){
    if(!BST) return null;    /* 查找失败 */
    if(X &gt; BST-&gt;Data){
        Find(X, BST-&gt;Right); /* 往右子树查找 */
    } else if(X &lt; BST-&gt;Data){
        Find(X, BST-&gt;Left);  /* 往左子树查找 */
    }else{  /* X == BST-&gt;Data */
        return BST;          /* 查找成功 */
    }
}
// 1. 递归函数效率低，非递归函数执行效率高
// 2. 尾递归函数均可改为迭代函数
// 非递归版本
Position Find(ElementType X, BinTree BST){
    while(BST){
        if(X &gt; BST-&gt;Data){
            BST = BST.Right;  /* 往右子树查找 */
        } else if(X &lt; BST-&gt;Data){
            BST = BST.Left;   /* 往左子树查找 */
        }else{
            return BST;       /* 查找成功 */
        }
    }
    return null;              /* 查找失败 */
}
</code></pre>
<ol start="2">
<li>Position FindMin(BinTree BST)：从二叉搜素树BST中查找并返回最小元素所在结点的地址</li>
</ol>
<pre><code class="language-C">// 递归
Position FindMin(BinTree BST){
    if(!BST) return null;
    if(BST-&gt;Left){
        return BST;
    }else{
        return FindMin(BST-&gt;Left);
    }
}
// 非递归
Position FindMin(BinTree BST){
    if(!BST) return null;
    while(BST-&gt;Left){
        BST = BST-&gt;Left;
    }
    return BST;
}
</code></pre>
<ol start="3">
<li>Position FindMax(BinTree BST)：从二叉搜素树BST中查找并返回最大元素所在结点的地址</li>
</ol>
<pre><code class="language-C">// 递归方式
Position FindMax(BinTree BST){
    if(!BST) return null;
    if(!BST-&gt;Right){
        return BST;
    }else{
        return FindMin(BST-&gt;Left);
    }
}
// 非递归
Position FindMax(BinTree BST){
    if(!BST) return null;
    while(BST-&gt;Right){
        BST = BST-&gt;Right;
    }
    return BST;
}
</code></pre>
<ol start="4">
<li>BinTree Insert(ElementType X, BinTree BST)：将元素X插入到二叉搜索树BST中</li>
</ol>
<pre><code class="language-C">BinTree Insert(ElementType X, BinTree BST){
    if(!BST){
        BST = malloc(sizeof(struct TreeNode));
        BST-&gt;Left = null;
        BST-&gt;Right = null;
    }else{
        if(X&gt;BST-&gt;Data){
            BST-&gt;Right = Insert(X, BST-&gt;Right);
        }else if(X&lt;BST-&gt;Data){
            BST-&gt;Left = Insert(X, BST-&gt;Left);
        }
    }
    return BST
}
</code></pre>
<ol start="5">
<li>BinTree Delete(ElementType X, BinTree BST)：从二叉搜索树BST中删除值等于元素X的结点</li>
</ol>
<pre><code class="language-C">BinTree Delete(ElementType X, BinTree BST){
    Position Tmp;
    if(!BST) printf(&quot;要深处的结点未找到&quot;)
    else if(X&gt;BST-&gt;Data){
        BST-&gt;Right = Delete(X, BST-&gt;Right);      /* 右子树递归删除 */
    }else if(X&lt;BST-&gt;Data){
        BST-&gt;Left = Delete(X, BST-&gt;Left);        /* 左子树递归删除 */
    }else{      /* 找到被删除结点时 */
        if(BST-&gt;Left&amp;&amp;BST-&gt;Right){               /* 删除的结点左子树和右子树都存在 */
            Tmp = FinMin(BST-&gt;Right);            /* 在右子树中找到最小结点填充自身 */
            BST-&gt;Data = Tmp-&gt;Data;                      
            BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right);  /* 右子树递归删除最小结点 */
        }else{   /* 被删除结点存在一个结点或结点均不存在时 */
            Tmp = BST;
            if(BST-&gt;Left){           /* 如果左结点存在 */
                BST = BST-&gt;Left;
            }else if(BST-&gt;Right){    /* 如果右结点存在 */
                 BST = BST-&gt;Right;  
            }
            free(Tmp);               /* 释放删除结点的空间 */
        }
    }
    return BST
}
</code></pre>
<h3 id="27-平衡二叉树">2.7 平衡二叉树</h3>
<h4 id="271-定义">2.7.1 定义</h4>
<p>平衡因子（Balanced Factor，BF）：BF(T) = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>L</mi></msub><mo>−</mo><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">h_L - h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">h_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别为T的左、右子树的高度。<br>
平衡二叉树（Balanced Binary Tree）：又叫AVL树，AVL树本质还是一棵二叉查找树，可为空树，或者任一结点的左、右子树高度差的绝对值不超过1，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi>F</mi><mo>(</mo><mi>T</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|BF(T)| \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<h4 id="272-性质">2.7.2 性质</h4>
<ol>
<li>给定n个结点的AVL树的最大高度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h=ceiling(log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，一个根节点时，h=0</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_h = n_{h-1} + n_{h-2} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ol>
<h4 id="271-操作">2.7.1 操作</h4>
<h5 id="2711-插入">2.7.1.1 插入</h5>
<p>插入后，计算各结点的BF值，将不平衡的结点标记为“发现者”，插入的结点为“麻烦结点”，据此有以下四种情况：</p>
<ol>
<li>麻烦结点在发现者的右子树的右边，称之为RR插入，需要RR旋转（右单旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345071314.png" alt="" loading="lazy"></li>
<li>麻烦结点在发现者的左子树的左边，称之为LL插入，需要LL旋转（左单旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345136195.png" alt="" loading="lazy"></li>
<li>麻烦结点在发现者的左子树的右边，称之为LR插入，需要LR旋转（左右双旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345262711.png" alt="" loading="lazy"></li>
<li>麻烦结点在发现者的右子树的左边，称之为RL插入，需要RL旋转（右左双旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345270024.png" alt="" loading="lazy"></li>
</ol>
<h3 id="28-堆">2.8 堆</h3>
<h4 id="281-定义">2.8.1 定义</h4>
<p>结构性：用数组表示的完全二叉树<br>
有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）</p>
<h4 id="282-操作">2.8.2 操作</h4>
<ol>
<li>创建</li>
</ol>
<pre><code class="language-C">typedef struct HeapStruct *MaxHeap;
struct HeapStruct{
    ElementType *Elements;    /* 存储堆元素的数组 */
    int Size;                 /* 堆当前元素的个数 */
    int Capacity;             /* 堆的最大容量 */
};

MaxHeap Create(int MaxSize){
    MaxHeap H = malloc(sizeof(struct HeapStruct));
    H-&gt;Elements = malloc((MaxSize+1)*sizeof(struct ElementType));
    H-&gt;Size = 0;
    H-&gt;Capacity = MaxSize;
    H-&gt;Elements[0] = MaxData;  /* 定义哨兵为大于堆中所有可能元素的值，以便于以后更快操作 */

    return H;
}
</code></pre>
<ol start="2">
<li>插入</li>
</ol>
<pre><code class="language-C">void Insert(MaxHeap H, ElementType item){
    int i;
    if(IsFull(H)){
        printf(&quot;最大堆已满&quot;);
        return ;
    }
    i = ++H-&gt;Size;
    for(;H-&gt;Elements[i/2]&lt;item;i/=2)
        H-&gt;Elements[i] = H-&gt;Elements[i/2]
    H-&gt;Elements[i] = item;
}
</code></pre>
<ol start="3">
<li>删除最大结点</li>
</ol>
<pre><code class="language-C">void DeleteMax(MaxHeap H){
    ElementType MaxItem, temp;
    int Parent, Child;
    if(IsEmpty(H)){
        printf(&quot;最大堆为空&quot;);
        return ;
    }
    MaxItem = H-&gt;Elements[1];
    temp = H-&gt;Elements[H-&gt;Size--];
    
    for(Parent=1;Parent*2&lt;=H-&gt;Size;Parent=Child){  
    /* Parent*2&lt;=H-&gt;Size 可判断Parent有没有左儿子 */
    /* 在完全二叉树中，编号为i结点的左右儿子编号分别为2i和2i+1 */
        Child = Parent/2;
        /* Child!=H-&gt;Size即Child小于H-&gt;Size，Child+1不越界且至多等于H-&gt;Size */
        if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Elements[Child]&lt;H-&gt;Elements[Child+1]))
            Child++;
        if(temp&gt;H-&gt;Elements[Child]) 
            break;
        else
            H-&gt;Elements[Parent] = H-&gt;Elements[Child];
    }
    H-&gt;Elements[Parent] = temp;
    return MaxItem;
}
</code></pre>
<h3 id="29-哈夫曼树">2.9 哈夫曼树</h3>
<h4 id="291-定义">2.9.1 定义</h4>
<p>带权路径长度（WPL）：设二叉树有n个叶子结点，每个叶子结点带有权值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，从根结点到每个叶子结点的长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">l_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则每个叶子结点的带权路径长度之和就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>w</mi><mi>k</mi></msub><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum_{k=1}^nw_kl_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
最优二叉树或哈夫曼树：WPL最小的二叉树</p>
<h4 id="292-性质">2.9.2 性质</h4>
<ol>
<li>没有度为1的结点；</li>
<li>n个叶子结点的哈夫曼树共有2n-1个结点。推导：二叉树有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_2=n_0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><mi>n</mi><mo>+</mo><mn>0</mn><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s=n_0+n_1+n_2=n+0+n-1=2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树</li>
<li>对同一组权值，可能存在不同构的哈夫曼树</li>
</ol>
<h4 id="293-操作">2.9.3 操作</h4>
<ol>
<li>创建</li>
</ol>
<pre><code class="language-C">/* 时间复杂度:O(NlogN) */
typedef struct TreeNode *HuffmanTree;
struct TreeNode{
    int Weight;
    HuffmanTree Left, Right;
}
HuffmanTree Huffman(MinHeap H){
    /* 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里 */
    int i;
    HuffmanTree T;
    BuildMinHeap(H); /* 将H-&gt;Elements[]按权值调整为最小堆 */
    for(i=1;i&lt;H-&gt;Size;i++){  /* 做H-&gt;Size-1次合并，n个结点两两合并只需n-1次 */
        T = malloc(sizeof(struct TreeNode)); /* 创建一个新的结点 */
        T-&gt;Left = DeleteMin(H);             
        T-&gt;Right = DeleteMin(H);
        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;
        Insert(H, T);   /* 将新T插入最小堆 */
    }
    T = DeleteMin(H);  /* 留在最小堆中的最后一个结点即为所求Huffman树的根结点 */
    return T;
}
</code></pre>
<h3 id="210-并查集">2.10 并查集</h3>
]]></content>
    </entry>
</feed>