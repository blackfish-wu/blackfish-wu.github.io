<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blackfish-wu.github.io/</id>
    <title>黑鱼的池塘</title>
    <updated>2020-03-20T11:55:01.807Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blackfish-wu.github.io/"/>
    <link rel="self" href="https://blackfish-wu.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blackfish-wu.github.io/images/avatar.png</logo>
    <icon>https://blackfish-wu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 黑鱼的池塘</rights>
    <entry>
        <title type="html"><![CDATA[TCP/IP 协议——链路层]]></title>
        <id>https://blackfish-wu.github.io/post/tcpip-xie-yi-lian-lu-ceng</id>
        <link href="https://blackfish-wu.github.io/post/tcpip-xie-yi-lian-lu-ceng">
        </link>
        <updated>2020-03-19T08:56:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-引言">1 引言</h3>
<ul>
<li>在TCP/IP协议族中，链路层主要有三个目的：
<ol>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答；</li>
<li>为RARP发送RARP请求和接收RARP应答</li>
</ol>
</li>
</ul>
<h3 id="2-以太网和ieee-802封装">2 以太网和IEEE 802封装</h3>
<h4 id="21-以太网">2.1 以太网</h4>
<ul>
<li>以太网是当今TCP/IP采用的主要的局域网技术，采用带冲突检测的载波侦听多路接入方法（CSMA/CD）</li>
<li>速率为10Mb/s，地址为48bit。</li>
<li>数据报封装在RFC 894中定义。</li>
<li>封装格式中，目标地址和源地址之后为2字节的“类型”字段，该字段定义了后续数据的类型。</li>
<li>类型字段之后就是数据，最少要有46字节，在不足的空间必须插入填充（pad）字节。</li>
<li>最后有4字节的CRC检验码，用于帧内后续字节差错的循环冗余码检验。</li>
</ul>
<h4 id="22-ieee-802">2.2 IEEE 802</h4>
<ul>
<li>IEEE 802是对IEEE公布的的标准集，其中802.3针对整个CSMA/CD网络，802.4针对令牌总线网络，802.5针对令牌环网路。</li>
<li>802.3允许使用16bit的地址，但一般是48bit。</li>
<li>数据报封装在RFC 1042中定义。</li>
<li>封装格式中，目标地址和源地址之后为2字节的“长度”字段，该字段指它后续数据的字节长度，但不包括CRC检验码。“类型”字段则由后续的子网接入协议（Sub-network Access Protocol, SNAP）的首部给出。802定义的有效长度值与以太网的有效类型值均不相同，通过该值可以区分两种帧格式。</li>
<li>长度字段之后是3字节的802.2 LLC和5字节的802.2 SNAP。其中，LLC包含目的服务访问点（DSAP）、源服务访问点和Ctrl字段，均为一个字节。SNAP包含3字节的org code和两个字节的“类型“字段。</li>
<li>数据部分至少38字节，在不足的空间必须插入填充（pad）字节。</li>
<li>最后有4字节的CRC检验码。<br>
<img src="https://blackfish-wu.github.io//post-images/1584623667338.png" alt="802与以太网的封装格式" loading="lazy"></li>
</ul>
<h4 id="23-尾部封装">2.3 尾部封装</h4>
<ul>
<li>是一个早期B S D系统在DEC VA X机上运行时的试验格式，它通过调整I P数据报中字段的次序来提高性能。</li>
<li>数据报封装在RFC 893中定义。</li>
<li>尾部封装已遭到反对。</li>
</ul>
<h4 id="24-以太网主机需求">2.4 以太网主机需求</h4>
<ol>
<li>必须能发送和接收采用RFC 894（以太网）封装格式的分组。</li>
<li>必须能接收与RFC 894混合的RFC 1042（IEEE 802）封装格式的分组。</li>
<li>也许能够发送采用RFC 1042格式封装的分组。发送的分组必须是可以设置的，而且默认条件下必须是RFC 894分组。</li>
</ol>
<h3 id="3-slip">3 SLIP</h3>
<h4 id="31-串行线路ip介绍">3.1 串行线路IP介绍</h4>
<ul>
<li>SLIP的全称是Serial Line IP，是一种广泛使用在串行线路上的协议，对IP数据报以简单形式进行封装。</li>
<li>数据报封装在RFC 1055中定义。</li>
<li>封装格式：
<ol>
<li>IP数据报以一个称作END（0xc0）的特殊字符开始和结束。</li>
<li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符。</li>
<li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。<br>
<img src="https://blackfish-wu.github.io//post-images/1584624111155.png" alt="SLIP报文的封装" loading="lazy"></li>
</ol>
</li>
<li>缺陷：
<ol>
<li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li>
<li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和。如果报文被线路噪声影响而发生错误，只能通过上层协议来发现。因此上层协议提供某种形式的CRC就显得很重要。</li>
</ol>
</li>
</ul>
<h4 id="32-压缩的slip">3.2 压缩的SLIP</h4>
<ul>
<li>由于串行线路的速率通常较低（ 19200 b/s或更低），而且通信经常是交互式的（如Telnet和Rlogin，二者都使用TCP），因此在SLIP线路上有许多小的TCP分组进行交换。为了传送1个字节的数据需要20个字节的IP首部和2 0个字节的TCP首部，总数超过40个字节。CSLIP（即压缩SLIP）的新协议就是为了解决SLIP性能上的缺陷。</li>
<li>在RFC 1144中被详细描述</li>
<li>CSLIP一般能把上面的40个字节压缩到3或5个字节。</li>
<li>现在大多数的SLIP产品都支持CSLIP。</li>
</ul>
<h3 id="4-ppp点对点协议">4 PPP：点对点协议</h3>
<h4 id="41-协议内容">4.1 协议内容</h4>
<p>RFC 1548描述了报文封装的方法和链路控制协议。RFC 1332描述了针对IP的网络控制协议。</p>
<ol>
<li>在串行链路上封装I P数据报的方法。P P P既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。</li>
<li>建立、配置及测试数据链路的链路控制协议（ LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li>
<li>针对不同网络层协议的网络控制协议（ NCP：Network Control Protocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。</li>
</ol>
<h4 id="42-数据帧格式">4.2 数据帧格式</h4>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584628171306.png" alt="PPP数据帧的格式" loading="lazy"></figure>
<ul>
<li>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</li>
<li>接下来是协议字段，类似于以太网中类型字段的功能。当它的值为0x0021时，表示信息字段是一个IP数据报；值为0xc021时，表示信息字段是链路控制数据；值为0x8021时，表示信息字段是网络控制数据。</li>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>转义：当遇到字符0x7e时，需连续传送两个字符： 0x7d和0x5e，以实现标志字符的转义。当遇到转义字符0x7d时，需连续传送两个字符： 0x7d和0x5d，以实现转义字符的转义。默认情况下，如果字符的值小于0x20，也需要转义以规避对控制字符的特殊转义。</li>
</ul>
<h4 id="43-优点">4.3 优点</h4>
<ul>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。</li>
</ul>
<h3 id="5-环回接口">5 环回接口</h3>
<ul>
<li>大多数的产品都支持环回接口（ Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。</li>
<li>A类网络号127就是为环回接口预留的。</li>
<li>一个传给环回接口的IP数据报不能在任何网络上出现。<br>
<img src="https://blackfish-wu.github.io//post-images/1584630544592.png" alt="环回接口处理IP数据报的过程" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP 协议——概述]]></title>
        <id>https://blackfish-wu.github.io/post/di-yi-tian</id>
        <link href="https://blackfish-wu.github.io/post/di-yi-tian">
        </link>
        <updated>2020-03-18T09:09:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-分层">1 分层</h3>
<h4 id="11-概述">1.1 概述</h4>
<p>TCP/IP通常被认为是一个四层协议系统</p>
<ol>
<li>应用层负责处理特定的应用程序细节。通用的应用程序：Telnet 远程登录；FTP文件传输协议；SMTP简单邮件传送协议；SNMP 简单网络管理协议。</li>
<li>运输层，主要为两台主机上的应用程序提供<strong>端到端</strong>的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。而另一方面， UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。</li>
<li>网络层，有时也称作互联网层，提供<strong>点到点</strong>的服务，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协（Internet组管理协议）。</li>
<li>链路层，有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。<br>
<img src="https://blackfish-wu.github.io//post-images/1584584791065.png" alt="" loading="lazy"></li>
</ol>
<h4 id="12-分层协议">1.2  分层协议</h4>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584584901048.png" alt="" loading="lazy"></figure>
<ul>
<li>运输层
<ul>
<li>TCP（传输控制协议）：TCP使用不可靠的IP服务，但它却提供一种可靠的运输层服务。</li>
<li>UDP（用户数据协议）：UDP是不可靠的，能为应用程序发送和接收数据报。一个数据报是指从发送方传输到接收方的一个信息单元。</li>
</ul>
</li>
<li>网络层
<ul>
<li>IP是网络层上的主要协议，同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。</li>
<li>ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</li>
<li>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</li>
</ul>
</li>
<li>链路层
<ul>
<li>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环<br>
网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
</ul>
</li>
</ul>
<h3 id="2-互联网地址和域名系统">2 互联网地址和域名系统</h3>
<h4 id="21-互联网地址">2.1 互联网地址</h4>
<figure data-type="image" tabindex="2"><img src="https://blackfish-wu.github.io//post-images/1584588205455.png" alt="五类互联网地址" loading="lazy"></figure>
<ul>
<li>长度为32bit，通常写成四个十进制的数，每个数为1个字节，范围从0-255</li>
<li>区分各类地址的最简单方法是看它的第一个十进制整数，下图列出了各类地址的起止范围。<br>
<img src="https://blackfish-wu.github.io//post-images/1584602058553.png" alt="各类IP地址的范围" loading="lazy"></li>
<li>多接口主机具有多个IP地址，其中每个接口都对应一个IP地址。</li>
<li>互联网上的每个接口必须有一个唯一的IP地址 为接入互联网的网络分配IP地址的机构叫互联网信息中心，称为InterNIC。InterNIC只分配网络号。主机号的分配由系统管理员来负责。</li>
<li>有三类IP地址：单播地址（目的为单个主机）、广播地址（目的端为给定网络上的所有主机）以及多播地址（目的端为同一组内的所有主机）</li>
</ul>
<h4 id="22-域名系统">2.2 域名系统</h4>
<ul>
<li>尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</li>
</ul>
<h3 id="3-封装和分用">3 封装和分用</h3>
<h4 id="31-封装">3.1 封装</h4>
<ul>
<li>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）</li>
<li>TCP传给IP的数据单元称作TCP报文段或简称为TCP段</li>
<li>IP传给网络接口层的数据单元称作IP数据报</li>
<li>通过以太网传输的比特流称作帧(Frame)<br>
<img src="https://blackfish-wu.github.io//post-images/1584602596706.png" alt="" loading="lazy"></li>
<li>UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作UDP数据报（UDP datagram），而且UDP的首部长为8字节。</li>
</ul>
<h4 id="32-分用">3.2 分用</h4>
<ul>
<li>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（ Demultiplexing）<br>
<img src="https://blackfish-wu.github.io//post-images/1584603217689.png" alt="以太网数据帧的分用过程" loading="lazy"></li>
</ul>
<h3 id="4-客户-服务器模型">4 客户-服务器模型</h3>
<ul>
<li>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服<br>
务器为客户提供一些特定的服务。可以将这种服务分为两种类型：重复型或并发型。</li>
<li>一般来说， TCP服务器是并发的，而UDP服务器是重复的</li>
</ul>
<h4 id="41-重复型">4.1 重复型</h4>
<ul>
<li>步骤如下：
<ol>
<li>等待一个客户请求的到来。</li>
<li>处理客户请求。</li>
<li>发送响应给发送请求的客户。</li>
<li>返回第1步。</li>
</ol>
</li>
<li>重复型服务器的问题主要在第2步，处理用户请求时无法为其他客户机提供服务。</li>
</ul>
<h4 id="42-并发型">4.2 并发型</h4>
<ul>
<li>步骤
<ol>
<li>等待一个客户请求的到来。</li>
<li>启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。</li>
<li>返回第1步。</li>
</ol>
</li>
<li>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。</li>
</ul>
<h3 id="5-端口号">5 端口号</h3>
<ul>
<li>TCP和UDP采用16 bit的端口号来识别应用程序。</li>
<li>服务器一般都是通过知名端口号来识别的。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。</li>
<li>客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以。客户端口号又称作<strong>临时端口号</strong>（即存在时间很短暂）。大多数TCP/IP实现给临时端口分配1024～5000之间的端口号。</li>
</ul>
<h3 id="6-标准化过程">6 标准化过程</h3>
<h4 id="61-标准化组织">6.1 标准化组织</h4>
<ol>
<li>Internet协会（ISOC，Internet Society）是一个推动、支持和促进Internet不断增长和发展的专业组织，它把Internet作为全球研究通信的基础设施。</li>
<li>Internet体系结构委员会（IAB，Internet Architecture Board）是一个技术监督和协调的机 构。它由国际上来自不同专业的15个志愿者组成，其职能是负责Internet标准的最后编辑和技术审核。IAB隶属于ISOC。</li>
<li>Internet工程专门小组（IETF，Internet Engineering Task Force）是一个面向近期标准的组织，它分为9个领域（应用、寻径和寻址、安全等等）。IETF开发成为Internet标准的规范。为帮助IETF主席，又成立了Internet工程指导小组（IESG, Internet Engineering Steering Group）。隶属于IAB。</li>
<li>Internet研究专门小组（IRIF，Internet Research Task Force）主要对长远的项目进行研究。隶属于IAB。</li>
</ol>
<h4 id="62-标准化文档">6.2 标准化文档</h4>
<ul>
<li>所有关于Internet的正式标准都以<strong>RFC</strong>（Request for Comment）文档出版。</li>
<li>大量的RFC并不是正式的标准，出版的目的只是为了提供信息。</li>
<li>RFC的篇幅从1页到200页不等。每一项都用一个数字来标识，如RFC1122，数字越大说明RFC的内容越新。</li>
</ul>
<h4 id="63-实现">6.3 实现</h4>
<ul>
<li>既成事实标准的TCP/IP软件实现来自于位于伯克利的加利福尼亚大学的计算机系统研究小组。</li>
<li>从历史上看，软件是随同4.x BSD系统（Berkeley Software Distribution）的网络版一起发布的。</li>
</ul>
<h4 id="64-接口">6.4 接口</h4>
<ul>
<li>使用TCP/IP协议的应用程序通常采用两种应用编程接口（AP I）：socket和TLI（运输层接口：Transport Layer Interface）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构——图]]></title>
        <id>https://blackfish-wu.github.io/post/shu-ju-jie-gou-tu</id>
        <link href="https://blackfish-wu.github.io/post/shu-ju-jie-gou-tu">
        </link>
        <updated>2019-10-07T14:51:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-介绍">1 介绍</h2>
<h3 id="11-定义">1.1 定义</h3>
<ul>
<li>表示“多对多”的关系</li>
<li>包含：
<ol>
<li>一组顶点：通常用V(Vertex)表示顶点集合</li>
<li>一组边：通常用E(Edge)表示边的集合：无向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo><mo>∈</mo><mi>E</mi><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">(v,w)\in E, 其中 v,w\in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>；有向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v,w&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>表示从v到w的边；不考虑重边和自会路</li>
</ol>
</li>
</ul>
<h3 id="12-常见术语">1.2 常见术语</h3>
<ul>
<li>无向图：所有的边都没有方向的图</li>
<li>有向图：边是有方向的</li>
<li>网络：边带权重的图</li>
<li>度：从顶点发出的边数为“出度”，指向该点的边数为“入度”</li>
<li>连通：如果从V到W存在一条(无向)路径，则称V和W是连通的</li>
<li>路径：V到W的路径是一系列顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>W</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{V, v_1, v_2, ..., v_n, W\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mclose">}</span></span></span></span>的集合，其中任一对相邻的顶点间都有图的边。<strong>路径的长度</strong>是路径中的边数（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同，则称为<strong>简单路径</strong></li>
<li>回路：起点等于终点的路径</li>
<li>连通图：图中任意两顶点均连通</li>
<li>连通分量：无向图的<strong>极大</strong>连通子图，极大表示：①顶点数极大，再加上一个顶点就不连通了。②边数极大，包含子图中的所有顶点相连的所有边。</li>
<li>强连通：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的</li>
<li>强连通图：有向图中任意两个顶点均强连通</li>
<li>强连通分量：有向图中的极大强连通子图</li>
</ul>
<h3 id="13-图的表示">1.3 图的表示</h3>
<h4 id="131-邻接矩阵">1.3.1 邻接矩阵</h4>
<ol>
<li>邻接矩阵G[N][N]——N个顶点从0到N-1编号</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">若</mi><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mi mathvariant="normal">是</mi><mi>G</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">边</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">否</mi><mi mathvariant="normal">则</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">G[i][j]=\begin{cases} 1&amp; 若&lt;v_i,v_j&gt;是G中的边\\ 0&amp; 否则 \end{cases} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">G</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">边</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">则</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ol start="2">
<li>邻接矩阵的特点：
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li>
<li>方便计算任一顶点的“度”</li>
</ul>
</li>
<li>邻接矩阵的缺点：
<ul>
<li>浪费空间————存稀疏图（点很多而边很少）有大量无效元素，但存稠密图（特别是完全图）挺合算</li>
<li>浪费时间————统计稀疏图中一共有多少条边</li>
</ul>
</li>
</ol>
<h4 id="132-邻接表">1.3.2 邻接表</h4>
<ol>
<li>邻接表：G[N]为指针数组，数组的每个元素存放一行链表的头结点，只存非0元素<br>
<img src="https://blackfish-wu.github.io//post-images/1570503578069.png" alt="" loading="lazy"></li>
<li>邻接表的特点：
<ul>
<li>方便找任一顶点中的所有“邻接点”</li>
<li>节约稀疏图的空间（需要N个头指针+2E个结点，E为边数）</li>
<li>方便计算无向图的度和有向图的出度，但不方便计算有向图的入度</li>
</ul>
</li>
<li>邻接表的缺点
<ul>
<li>本身多了一个指针域，表示网络来说，多了一个权重域，所以仅适用于表达稀疏图</li>
<li>不方便计算有向图的入度（除非再构造一个“逆邻接表”）</li>
</ul>
</li>
</ol>
<h3 id="14-图的遍历">1.4 图的遍历</h3>
<h4 id="141-深度优先遍历depth-fisrt-searchdfs">1.4.1 深度优先遍历（Depth Fisrt Search，DFS）</h4>
<pre><code class="language-C">/* 伪代码 */
void DFS(Vertex V){
    visited[V] = true;
    for(V的每个邻接点W)
        if(!visited[W])
            DFS(W);
}
</code></pre>
<ul>
<li>用邻接表存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> (N为结点数，E为边数)</li>
<li>用邻接矩阵存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="142-广度优先遍历breadth-fisrt-searchbfs">1.4.2 广度优先遍历（Breadth Fisrt Search，BFS）</h4>
<pre><code class="language-C">/* 伪代码 */
void BFS(Vertex V){
    visited[V] = true;
    Enqueue(V, Q);
    while(!IsEmpty(Q)){
        V = Dequeue(Q);
        for(V的每个邻接点W){
            if(!visited[W]){
                visited[W] = true;
                Enqueue(V, Q);
            }
        }
    }
}
</code></pre>
<ul>
<li>用邻接表存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> (N为结点数，E为边数)</li>
<li>用邻接矩阵存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="2-最短路径">2 最短路径</h2>
<h3 id="21-定义">2.1 定义</h3>
<ul>
<li>最短路径：在网络中，求两个顶点间的所有路径中，边权值之和最小的那条路径就是这两点间的最短路径。</li>
<li>源点：求最短路径时的起点称之为源点</li>
<li>终点：求最短路径时的终点称之为终点</li>
<li>单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径</li>
<li>多源最短路径问题：求任意两顶点间的最短路径</li>
</ul>
<h3 id="22-方法">2.2 方法</h3>
<h4 id="221-无权图的单源最短路算法">2.2.1 无权图的单源最短路算法</h4>
<pre><code class="language-C">// T = O(|V|+|E|)
void Unweighted( Vertex S ){
    Enqueue(S, Q);
    while(!IsEmpty(Q)){
        V = Dequeue(Q);
        for(V的每个邻接点W){
            if(dist[W]==-1){
                dist[W] = dist[V]+1;
                path[W] = V;
                Enqueue(W, Q);
            }
        }
    }
}
</code></pre>
<h4 id="222-有权图的单源最短路算法dijkstra算法">2.2.2 有权图的单源最短路算法——Dijkstra算法</h4>
<ul>
<li>令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mi mathvariant="normal">源</mi><mi mathvariant="normal">点</mi><mi>s</mi><mo>+</mo><mi mathvariant="normal">已</mi><mi mathvariant="normal">经</mi><mi mathvariant="normal">确</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">短</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">顶</mi><mi mathvariant="normal">点</mi><msub><mi>v</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">S=\{源点s+已经确定了最短路径的顶点v_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord cjk_fallback">源</span><span class="mord cjk_fallback">点</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">短</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li>
<li>对任一未收录的顶点v，定义dist[V]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>s</mi><mo>→</mo><mo>(</mo><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>S</mi><mo>)</mo><mo>→</mo><mi>v</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{s\rightarrow (v_i \in S)\rightarrow v\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">}</span></span></span></span>的最小长度</li>
<li>真正的最短路径只经过S中的顶点</li>
<li>每次从未收录的顶点中选一个dist最小的收录（贪心）：如果采用遍历的方式获得dist最小，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|V|^2+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>；如果采用最小堆的方法建立和获得最小dist，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|V|log(|V|)+|E|log(|V|))=O(|E|log(|V|))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>增加一个v到S，可能影响另外一个w的dist值</li>
</ul>
<pre><code class="language-C">void Dijkstra(Vertex S){
    while(1){
        V = 未收录顶点中dist最小者;
        if(V不存在)
            break;
        collected[V] = true;
        for(V的每个邻接点W){
            if(collected[W] = false){
                if(dist[V]+E&lt;v,w&gt; &lt; dist[W]){
                    dist[W] = dist[V]+E&lt;v,w&gt;;
                    path[W] = V;
                }
            }
        }
    }
}
</code></pre>
<h4 id="223-多源最短路算法floyd算法">2.2.3 多源最短路算法——Floyd算法</h4>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mo>{</mo><mi>i</mi><mo>→</mo><mo>{</mo><mi>l</mi><mo>≤</mo><mi>k</mi><mo>}</mo><mo>→</mo><mi>j</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">D^k[i][j]=路径\{i \rightarrow \{l\le k\}\rightarrow j\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mopen">{</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mn>0</mn></msup><mo separator="true">,</mo><msup><mi>D</mi><mn>1</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>D</mi><mrow><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">D^0, D^1, ..., D^{|v|-1}[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mtight">∣</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>即给出了从0到|v|-1逐次加入顶点后i到j的最短距离矩阵</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>应为带权的邻接矩阵，对角线为0</li>
<li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>已经完成，递推到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">D^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>时：如果新加入的顶点k不影响<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>各个顶点彼此间最短路径，则不需要更新；反之，如果影响了，那么影响后的最短路径必然由两段最短路径组成，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">D^k[i][j]=D^{k-1}[i][k]+D^{k-1}[k][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Floyd(){
    for(i=0;i&lt;N;i++){
        for(j=0;j&lt;n;j++){
            D[i][j] = G[i][j];
            path[i][j] = -1;
        }
    }
    for(k=0;k&lt;N;k++)
        for(i=0;i&lt;N;i++){
            for(j=0;j&lt;n;j++)
                if(D[i][k]+D[k][j]&lt;D[i][j]){
                    D[i][j] = D[i][k]+D[k][j];
                    path[i][j] = k;
                }
            }
}
</code></pre>
<h2 id="3-最小生成树">3 最小生成树</h2>
<h3 id="31-定义">3.1 定义</h3>
<ul>
<li>是一棵无回路的树，|V|个顶点一定有|V|-1条边</li>
<li>包含了全部的顶点，|V|-1条边都在路里</li>
<li>|V|-1条边的权重和最小</li>
</ul>
<h3 id="32-方法">3.2 方法</h3>
<h4 id="321-prim算法">3.2.1 Prim算法</h4>
<pre><code class="language-C">void Prim(Vertex s){
    MST = {s};
    while(1){
        v = 未收录顶点中dist最小的;
        if(这样的V不存在)
            break;
        将V收录进MST: dist[v] = 0;
        for(v的每个邻接点W){
            if(W未被收录)
                if(E&lt;v,w&gt; &lt; dist[w]){
                    dist[W] = E&lt;v,w&gt;;
                }
        }
    }
}
</code></pre>
<h4 id="322-kruskal算法将森林合并成树">3.2.2 Kruskal算法——将森林合并成树</h4>
<ul>
<li>思路：从图中每次找到边权值最小的边，如果该边不构成回路，则加入到生成树集合；如果构成，删除掉该边</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|E|log(|E|))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Kruskal(Vertex s){
    MST = {};
    while(MST中的边不到|V|-1条&amp;&amp;E中还有边){
        e=E中权重最小的边；            /* 最小堆 */
        Delete(E, e); 
        if(e加入到MST没有构成最小回路)  /* 并查集 */
            e 加入到 MST;
    }
    if( MST中的边不到|V|-1条 )
        Error(&quot;生成树不存在&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OGC的Simple Features Access(ISO 19125)标准]]></title>
        <id>https://blackfish-wu.github.io/post/ogc-de-simple-features-accessiso-19125biao-zhun</id>
        <link href="https://blackfish-wu.github.io/post/ogc-de-simple-features-accessiso-19125biao-zhun">
        </link>
        <updated>2019-09-23T12:29:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-简介">1 简介</h2>
<p>OpenGIS定义的Simple Features Access（SFA， ISO 19125）标准的第二部分定义了包含了空间和非空间属性的要素集合的标准SQL模式。这里的要素集是指带地理属性的表。该标准主要包含以下4点：</p>
<ol>
<li>确立了一个表达要素的框架</li>
<li>确立了框架的一系列术语的定义</li>
<li>定义了一个用于定义几何属性的简单几何概述</li>
<li><strong>描述了一系列SQL几何类型及其对应的SQL函数</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构——树]]></title>
        <id>https://blackfish-wu.github.io/post/shu</id>
        <link href="https://blackfish-wu.github.io/post/shu">
        </link>
        <updated>2019-09-19T02:18:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-树的表示">1 树的表示</h2>
<h3 id="11-儿子兄弟表示法">1.1 儿子兄弟表示法</h3>
<p>结点设置两个指针域，一个指向儿子，一个指向右侧的第一个兄弟<br>
<img src="https://blackfish-wu.github.io//post-images/1568859566733.png" alt="" loading="lazy"></p>
<h2 id="2-二叉树">2 二叉树</h2>
<h3 id="21-定义">2.1 定义</h3>
<p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构，结点有左右之分。</p>
<h3 id="22-特殊二叉树">2.2 特殊二叉树</h3>
<ol>
<li>斜二叉树（Skewed Binary Tree）: 只有左子节点或只有右子节点的二叉树称为斜二叉树</li>
<li>满二叉树（Full Binary Tree）：又叫完美二叉树（Perfect Binary Tree）。除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。</li>
<li>完全二叉树（Compelete Binary Tree）：对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。</li>
</ol>
<h3 id="23-性质">2.3 性质</h3>
<ol>
<li>一个二叉树的第i层的最大结点数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{i-1}, i \geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>深度为k的二叉树最大结点数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1, k \geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>对于任何一颗非空二叉树T，假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示叶结点的个数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示度为2的结点个数，则两者满足关系<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0 = n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。推导：边总数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>−</mo><mn>1</mn><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s=n_0+n_1+n_2-1=n_1+2n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<h3 id="24-存储结构">2.4 存储结构</h3>
<h4 id="241-顺序存储结构">2.4.1 顺序存储结构</h4>
<ul>
<li>完全二叉树：按从上至下、从左至右顺序存储到数组。非根结点的父节点序号是[i/2]，结点的左孩子序号是2i，结点的右孩子序号是2i+1</li>
<li>一般二叉树：同样可以按照这种结构，但是会造成空间浪费<br>
<img src="https://blackfish-wu.github.io//post-images/1569569016795.png" alt="" loading="lazy"></li>
</ul>
<h4 id="242-链表存储结构">2.4.2 链表存储结构</h4>
<p>定义一个左指针、数据和右指针的结构体来存放结点</p>
<h3 id="25-遍历">2.5 遍历</h3>
<h4 id="251-递归遍历">2.5.1 递归遍历</h4>
<ol>
<li>先序遍历：（1）先访问节点；（2）先序遍历左子树；（3）先序遍历右子树</li>
</ol>
<pre><code class="language-C">void PreOrderTraversal( BinTree BT )
    if(BT){
        printf(&quot;%d&quot;, BT-&gt;Data);
        PreOrderTraversal( BT-&gt;Left );
        PreOrderTraversal( BT-&gt;Right );
    }
</code></pre>
<ol start="2">
<li>中序遍历：（1）先序遍历左子树；（2）访问根节点；（3）先序遍历右子树</li>
</ol>
<pre><code class="language-C">void InOrderTraversal( BinTree BT )
    if(BT){
        InOrderTraversal( BT-&gt;Left );
        printf(&quot;%d&quot;, BT-&gt;Data);
        InOrderTraversal( BT-&gt;Right );
    }
</code></pre>
<ol start="3">
<li>后序遍历：（1）先序遍历左子树；（2）先序遍历右子树；（3）访问根节点</li>
</ol>
<pre><code class="language-C">void PostOrderTraversal( BinTree BT )
    if(BT){
        PostOrderTraversal( BT-&gt;Left );
        PostOrderTraversal( BT-&gt;Right );
        printf(&quot;%d&quot;, BT-&gt;Data);
    }
</code></pre>
<h4 id="252-非递归遍历">2.5.2 非递归遍历</h4>
<ol>
<li>前序遍历：（1）访问并遍历左结点（2）从栈中取出结点；（3）访问右结点，回到（1）</li>
</ol>
<pre><code class="language-C">void PreOrderTraversal( BinTree BT ){
    BinTree T = BT;
    Stack S = CreateStack( MaxSize );
    while( T || !IsEmpty(S) ){
        while( T ){
            printf(&quot;%5d&quot;, T-&gt;Data);
            Push(S,T);
            T = T-&gt;Left;
        }
        while( !IsEmpty(S) ){
            T = Pop(S);
            T = T-&gt;Right;
        }
    }
}
</code></pre>
<ol start="2">
<li>中序遍历：（1）先遍历左子树，压入栈中，直至左子树为空；（2）从栈中取出一个结点，访问它；（3）讲该结点的右子树作为起始结点，回到（1）</li>
</ol>
<pre><code class="language-C">void InOrderTraversal( BinTree BT ){
    BinTree T = BT;
    Stack S = CreateStack( MaxSize );
    while( T || !IsEmpty(S) ){
        while( T ){
            Push(S,T);
            T = T-&gt;Left;
        }
        while( !IsEmpty(S) ){
            T = Pop(S);
            printf(&quot;%5d&quot;, T-&gt;Data);
            T = T-&gt;Right;
        }
    }
}
</code></pre>
<ol start="3">
<li>后序遍历：（1）当前结点左子树不为空且左孩子和右孩子没有被访问过的情况下，不断入栈左子树；（2）左子树访问结束，判断当前结点是否有右孩子且右孩子没有访问过的情况下，入栈右孩子，回到步骤（1）；（3）当最后一个右孩子被访问到时，开始出栈并访问该结点。</li>
</ol>
<pre><code class="language-C">void PostOrderTraversal( BinTree BT ){
    BinTree T = BT;
    Set Visited = CreateSet( MaxSize );
    Stack S = CreateStack( MaxSize );
    Push(Visited, T);
    Push(S, T);
    while(!IsEmpty(Visited)){
        // 查看栈顶的结点左右结点是否为空或左右结点是否都被访问过
        BinTree Node = findUnvisitedNode(Peak(S), Visited);
        if(Node==null){
            T = Pop(S);
            printf(&quot;%d&quot;, T-&gt;data);
        }else{
            Push(visited, Node);
            Push(S, Node);
        }
    }
}

BinTree findUnvisitedNode(BinTree Node, Set Visited){
    if (Node-&gt;left != null &amp;&amp; !Visited.contains(Node-&gt;left)) {
        return Node.left;
    } else if (Node-&gt;right != null &amp;&amp; !Visited.contains(Node-&gt;right))
        return Node-&gt;right;
    else
        return null;
}
</code></pre>
<h3 id="26-二叉搜索树">2.6 二叉搜索树</h3>
<h4 id="261-定义">2.6.1 定义</h4>
<p>二叉搜索树：一棵二叉树，可以为空，如果不为空，满足一下性质：</p>
<ol>
<li>非空左子树的所有键值小于根结点的键值。</li>
<li>非空右子树的所有键值大于根结点的键值。</li>
<li>左、右子树都是二叉搜索树。</li>
</ol>
<h4 id="261-操作函数">2.6.1 操作函数</h4>
<ol>
<li>Position Find(ElementType X, BinTree BST)：从二叉树BST中查找元素X，返回结点所在的地址</li>
</ol>
<pre><code class="language-C">// 递归版本
Position Find(ElementType X, BinTree BST){
    if(!BST) return null;    /* 查找失败 */
    if(X &gt; BST-&gt;Data){
        Find(X, BST-&gt;Right); /* 往右子树查找 */
    } else if(X &lt; BST-&gt;Data){
        Find(X, BST-&gt;Left);  /* 往左子树查找 */
    }else{  /* X == BST-&gt;Data */
        return BST;          /* 查找成功 */
    }
}
// 1. 递归函数效率低，非递归函数执行效率高
// 2. 尾递归函数均可改为迭代函数
// 非递归版本
Position Find(ElementType X, BinTree BST){
    while(BST){
        if(X &gt; BST-&gt;Data){
            BST = BST.Right;  /* 往右子树查找 */
        } else if(X &lt; BST-&gt;Data){
            BST = BST.Left;   /* 往左子树查找 */
        }else{
            return BST;       /* 查找成功 */
        }
    }
    return null;              /* 查找失败 */
}
</code></pre>
<ol start="2">
<li>Position FindMin(BinTree BST)：从二叉搜素树BST中查找并返回最小元素所在结点的地址</li>
</ol>
<pre><code class="language-C">// 递归
Position FindMin(BinTree BST){
    if(!BST) return null;
    if(BST-&gt;Left){
        return BST;
    }else{
        return FindMin(BST-&gt;Left);
    }
}
// 非递归
Position FindMin(BinTree BST){
    if(!BST) return null;
    while(BST-&gt;Left){
        BST = BST-&gt;Left;
    }
    return BST;
}
</code></pre>
<ol start="3">
<li>Position FindMax(BinTree BST)：从二叉搜素树BST中查找并返回最大元素所在结点的地址</li>
</ol>
<pre><code class="language-C">// 递归方式
Position FindMax(BinTree BST){
    if(!BST) return null;
    if(!BST-&gt;Right){
        return BST;
    }else{
        return FindMin(BST-&gt;Left);
    }
}
// 非递归
Position FindMax(BinTree BST){
    if(!BST) return null;
    while(BST-&gt;Right){
        BST = BST-&gt;Right;
    }
    return BST;
}
</code></pre>
<ol start="4">
<li>BinTree Insert(ElementType X, BinTree BST)：将元素X插入到二叉搜索树BST中</li>
</ol>
<pre><code class="language-C">BinTree Insert(ElementType X, BinTree BST){
    if(!BST){
        BST = malloc(sizeof(struct TreeNode));
        BST-&gt;Left = null;
        BST-&gt;Right = null;
    }else{
        if(X&gt;BST-&gt;Data){
            BST-&gt;Right = Insert(X, BST-&gt;Right);
        }else if(X&lt;BST-&gt;Data){
            BST-&gt;Left = Insert(X, BST-&gt;Left);
        }
    }
    return BST
}
</code></pre>
<ol start="5">
<li>BinTree Delete(ElementType X, BinTree BST)：从二叉搜索树BST中删除值等于元素X的结点</li>
</ol>
<pre><code class="language-C">BinTree Delete(ElementType X, BinTree BST){
    Position Tmp;
    if(!BST) printf(&quot;要深处的结点未找到&quot;)
    else if(X&gt;BST-&gt;Data){
        BST-&gt;Right = Delete(X, BST-&gt;Right);      /* 右子树递归删除 */
    }else if(X&lt;BST-&gt;Data){
        BST-&gt;Left = Delete(X, BST-&gt;Left);        /* 左子树递归删除 */
    }else{      /* 找到被删除结点时 */
        if(BST-&gt;Left&amp;&amp;BST-&gt;Right){               /* 删除的结点左子树和右子树都存在 */
            Tmp = FinMin(BST-&gt;Right);            /* 在右子树中找到最小结点填充自身 */
            BST-&gt;Data = Tmp-&gt;Data;                      
            BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right);  /* 右子树递归删除最小结点 */
        }else{   /* 被删除结点存在一个结点或结点均不存在时 */
            Tmp = BST;
            if(BST-&gt;Left){           /* 如果左结点存在 */
                BST = BST-&gt;Left;
            }else if(BST-&gt;Right){    /* 如果右结点存在 */
                 BST = BST-&gt;Right;  
            }
            free(Tmp);               /* 释放删除结点的空间 */
        }
    }
    return BST
}
</code></pre>
<h3 id="27-平衡二叉树">2.7 平衡二叉树</h3>
<h4 id="271-定义">2.7.1 定义</h4>
<p>平衡因子（Balanced Factor，BF）：BF(T) = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>L</mi></msub><mo>−</mo><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">h_L - h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">h_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别为T的左、右子树的高度。<br>
平衡二叉树（Balanced Binary Tree）：又叫AVL树，AVL树本质还是一棵二叉查找树，可为空树，或者任一结点的左、右子树高度差的绝对值不超过1，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi>F</mi><mo>(</mo><mi>T</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|BF(T)| \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<h4 id="272-性质">2.7.2 性质</h4>
<ol>
<li>给定n个结点的AVL树的最大高度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h=ceiling(log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，一个根节点时，h=0</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_h = n_{h-1} + n_{h-2} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ol>
<h4 id="271-操作">2.7.1 操作</h4>
<h5 id="2711-插入">2.7.1.1 插入</h5>
<p>插入后，计算各结点的BF值，将不平衡的结点标记为“发现者”，插入的结点为“麻烦结点”，据此有以下四种情况：</p>
<ol>
<li>麻烦结点在发现者的右子树的右边，称之为RR插入，需要RR旋转（右单旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345071314.png" alt="" loading="lazy"></li>
<li>麻烦结点在发现者的左子树的左边，称之为LL插入，需要LL旋转（左单旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345136195.png" alt="" loading="lazy"></li>
<li>麻烦结点在发现者的左子树的右边，称之为LR插入，需要LR旋转（左右双旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345262711.png" alt="" loading="lazy"></li>
<li>麻烦结点在发现者的右子树的左边，称之为RL插入，需要RL旋转（右左双旋）<br>
<img src="https://blackfish-wu.github.io//post-images/1570345270024.png" alt="" loading="lazy"></li>
</ol>
<h3 id="28-堆">2.8 堆</h3>
<h4 id="281-定义">2.8.1 定义</h4>
<p>结构性：用数组表示的完全二叉树<br>
有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）</p>
<h4 id="282-操作">2.8.2 操作</h4>
<ol>
<li>创建</li>
</ol>
<pre><code class="language-C">typedef struct HeapStruct *MaxHeap;
struct HeapStruct{
    ElementType *Elements;    /* 存储堆元素的数组 */
    int Size;                 /* 堆当前元素的个数 */
    int Capacity;             /* 堆的最大容量 */
};

MaxHeap Create(int MaxSize){
    MaxHeap H = malloc(sizeof(struct HeapStruct));
    H-&gt;Elements = malloc((MaxSize+1)*sizeof(struct ElementType));
    H-&gt;Size = 0;
    H-&gt;Capacity = MaxSize;
    H-&gt;Elements[0] = MaxData;  /* 定义哨兵为大于堆中所有可能元素的值，以便于以后更快操作 */

    return H;
}
</code></pre>
<ol start="2">
<li>插入</li>
</ol>
<pre><code class="language-C">void Insert(MaxHeap H, ElementType item){
    int i;
    if(IsFull(H)){
        printf(&quot;最大堆已满&quot;);
        return ;
    }
    i = ++H-&gt;Size;
    for(;H-&gt;Elements[i/2]&lt;item;i/=2)
        H-&gt;Elements[i] = H-&gt;Elements[i/2]
    H-&gt;Elements[i] = item;
}
</code></pre>
<ol start="3">
<li>删除最大结点</li>
</ol>
<pre><code class="language-C">void DeleteMax(MaxHeap H){
    ElementType MaxItem, temp;
    int Parent, Child;
    if(IsEmpty(H)){
        printf(&quot;最大堆为空&quot;);
        return ;
    }
    MaxItem = H-&gt;Elements[1];
    temp = H-&gt;Elements[H-&gt;Size--];
    
    for(Parent=1;Parent*2&lt;=H-&gt;Size;Parent=Child){  
    /* Parent*2&lt;=H-&gt;Size 可判断Parent有没有左儿子 */
    /* 在完全二叉树中，编号为i结点的左右儿子编号分别为2i和2i+1 */
        Child = Parent/2;
        /* Child!=H-&gt;Size即Child小于H-&gt;Size，Child+1不越界且至多等于H-&gt;Size */
        if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Elements[Child]&lt;H-&gt;Elements[Child+1]))
            Child++;
        if(temp&gt;H-&gt;Elements[Child]) 
            break;
        else
            H-&gt;Elements[Parent] = H-&gt;Elements[Child];
    }
    H-&gt;Elements[Parent] = temp;
    return MaxItem;
}
</code></pre>
<h3 id="29-哈夫曼树">2.9 哈夫曼树</h3>
<h4 id="291-定义">2.9.1 定义</h4>
<p>带权路径长度（WPL）：设二叉树有n个叶子结点，每个叶子结点带有权值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，从根结点到每个叶子结点的长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">l_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则每个叶子结点的带权路径长度之和就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>w</mi><mi>k</mi></msub><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum_{k=1}^nw_kl_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
最优二叉树或哈夫曼树：WPL最小的二叉树</p>
<h4 id="292-性质">2.9.2 性质</h4>
<ol>
<li>没有度为1的结点；</li>
<li>n个叶子结点的哈夫曼树共有2n-1个结点。推导：二叉树有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_2=n_0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><mi>n</mi><mo>+</mo><mn>0</mn><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s=n_0+n_1+n_2=n+0+n-1=2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树</li>
<li>对同一组权值，可能存在不同构的哈夫曼树</li>
</ol>
<h4 id="293-操作">2.9.3 操作</h4>
<ol>
<li>创建</li>
</ol>
<pre><code class="language-C">/* 时间复杂度:O(NlogN) */
typedef struct TreeNode *HuffmanTree;
struct TreeNode{
    int Weight;
    HuffmanTree Left, Right;
}
HuffmanTree Huffman(MinHeap H){
    /* 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里 */
    int i;
    HuffmanTree T;
    BuildMinHeap(H); /* 将H-&gt;Elements[]按权值调整为最小堆 */
    for(i=1;i&lt;H-&gt;Size;i++){  /* 做H-&gt;Size-1次合并，n个结点两两合并只需n-1次 */
        T = malloc(sizeof(struct TreeNode)); /* 创建一个新的结点 */
        T-&gt;Left = DeleteMin(H);             
        T-&gt;Right = DeleteMin(H);
        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;
        Insert(H, T);   /* 将新T插入最小堆 */
    }
    T = DeleteMin(H);  /* 留在最小堆中的最后一个结点即为所求Huffman树的根结点 */
    return T;
}
</code></pre>
<h3 id="210-并查集">2.10 并查集</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ArcGIS10.3 发布要素服务的流程(SQLServer)]]></title>
        <id>https://blackfish-wu.github.io/post/arcgis103-fa-bu-yao-su-fu-wu-de-liu-cheng-sqlserver</id>
        <link href="https://blackfish-wu.github.io/post/arcgis103-fa-bu-yao-su-fu-wu-de-liu-cheng-sqlserver">
        </link>
        <updated>2019-08-16T14:02:01.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>创建企业地理数据库<br>
<img src="https://blackfish-wu.github.io//post-images/1565964186616.png" alt="" loading="lazy"></li>
<li>创建数据库连接<br>
<img src="https://blackfish-wu.github.io//post-images/1565964341417.png" alt="" loading="lazy"></li>
<li>将待发布为要素服务的数据导入该数据库中。<br>
<img src="https://blackfish-wu.github.io//post-images/1565964347628.png" alt="" loading="lazy"></li>
<li>右键选择该要素，将其注册为版本化数据<br>
<img src="https://blackfish-wu.github.io//post-images/1565964354123.png" alt="" loading="lazy"></li>
<li>创建arcgis server，账号密码为arcgis server manager登录的账号密码<br>
<img src="https://blackfish-wu.github.io//post-images/1565964371531.png" alt="" loading="lazy"></li>
<li>打开服务属性。<br>
<img src="https://blackfish-wu.github.io//post-images/1565964378603.png" alt="" loading="lazy"></li>
<li>为服务配置数据库连接属性。在选择“是否跟发布的数据库连接相同连接（same as pubilisher database connection）”选项时，应注意arcgis server服务登录的账号是否为本地账户（打开“运行”，输入services.msc，找到arcgis server 服务，右键属性，打开登录标签，查看是否为本地系统账户），如果是就勾选。<br>
<img src="https://blackfish-wu.github.io//post-images/1565964387856.png" alt="" loading="lazy"></li>
<li>将放置到SDE的图层加载到ArcMap上，选择share as service，勾选要素服务进行发布。</li>
<li>打开manager， 查看服务是否能正常开启。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python环境中使Arcpy]]></title>
        <id>https://blackfish-wu.github.io/post/python-huan-jing-zhong-shi-yong-arcpy</id>
        <link href="https://blackfish-wu.github.io/post/python-huan-jing-zhong-shi-yong-arcpy">
        </link>
        <updated>2019-08-16T09:33:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="手动添加依赖">手动添加依赖</h4>
<p>在import arcpy之前添加相关的包路径到sys.path即可，<strong>路径以本机安装ArcGIS的路径和版本为准</strong></p>
<pre><code class="language-Python">import sys
sys.path.append(&quot;C:\Python27\ArcGIS10.5\Lib\site-packages&quot;)
sys.path.append(&quot;D:\Software\ArcGIS\Desktop10.5\arcpy&quot;)
sys.path.append(&quot;D:\Software\ArcGIS\Desktop10.5\ArcToolbox\Scripts&quot;)
sys.path.append(&quot;D:\Software\ArcGIS\Desktop10.5\bin&quot;)
sys.path.append(&quot;C:\Python27\ArcGIS10.5\Lib&quot;)
</code></pre>
<h4 id="非手动方式">非手动方式</h4>
<p>每次用到arcpy均要添加相关包有些麻烦。为了避免这种情况，可以直接在[python根目录]\Lib\site-packages下添加一个后缀为.pth的文件，使用记事本打开并添加相关路径，例如：</p>
<pre><code># [python根目录]\Lib\site-packages\arcpy.pth

C:\Python27\ArcGIS10.5\Lib\site-packages
D:\Software\ArcGIS\Desktop10.5\arcpy
D:\Software\ArcGIS\Desktop10.5\ArcToolbox\Scripts
D:\Software\ArcGIS\Desktop10.5\bin
C:\Python27\ArcGIS10.5\Lib
</code></pre>
<h4 id="出错原因">出错原因</h4>
<ol>
<li>DLL %1......：配置的Python环境和ArcGIS使用的Python不是一个C++编辑器编译的，ArcGIS使用的是2.7的32位版本</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://blackfish-wu.github.io/post/hello-gridea</id>
        <link href="https://blackfish-wu.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>