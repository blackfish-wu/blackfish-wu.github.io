<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blackfish-wu.github.io/</id>
    <title>黑鱼的池塘</title>
    <updated>2020-04-07T16:11:52.917Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blackfish-wu.github.io/"/>
    <link rel="self" href="https://blackfish-wu.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blackfish-wu.github.io/images/avatar.png</logo>
    <icon>https://blackfish-wu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 黑鱼的池塘</rights>
    <entry>
        <title type="html"><![CDATA[面试题汇总]]></title>
        <id>https://blackfish-wu.github.io/post/mian-shi-ti-hui-zong/</id>
        <link href="https://blackfish-wu.github.io/post/mian-shi-ti-hui-zong/">
        </link>
        <updated>2020-03-28T16:00:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="tcpip">TCP/IP</h3>
<p>《计算机网络原理：自顶向下方法》《TCP/IP详解卷1》《图解TCP/IP》《图解HTTP》</p>
<ol>
<li>TCP和UDP的区别和优缺点？<br>
<a href="https://blog.csdn.net/xiaobangkuaipao/article/details/76793702">参考</a></li>
<li>三次握手四次挥手的过程
<ul>
<li>三次握手：
<ul>
<li>客户端和服务器都建立TCB</li>
<li>客户端向服务端发送TCP报文，其中SYN指针设置为1，消耗一个序列号，进入同步发送状态；不能携带数据。</li>
<li>服务端向客户端发送TCP报文，其中SYN指针设置为1，ACK指针设置为1，消耗自己序列号1个，确认序列号为客户序列号加1，进入同步接收状态；不能携带数据。</li>
<li>客户端发送，ACK指针设置为1，确认序列号为服务端序列号，此时可以携带数据，如果不发送数据就不消耗序列号。进入已建立状态。</li>
<li>服务端收到确认报文后也进入建立状态。</li>
</ul>
</li>
<li>四次挥手
<ul>
<li>客户端发送FIN指针为1，序列号为x；进入终止等待1状态；</li>
<li>服务端发送ACK指针为1，序列号为y，确认序列号为x+1；服务端进入关闭等待状态；客户端收到时进入终止等待2状态；</li>
<li>服务端发送FIN指针为1，FIN=1，ACK=1，seq=z，ack=x+1；服务端进入关闭等待状态；</li>
<li>客户端接收后发送一个ACK=1，ack，seq的报文，进入时间等待状态；等待两倍最大报文段寿命后关闭。</li>
<li>服务端接收到后直接关闭。</li>
</ul>
</li>
</ul>
</li>
<li>能不能两次握手<br>
不能。假如客户端发送了一次握手后由于网络延迟原因晚到达，在这期间要是客户端再次发送确认，在服务器收到第二次同步请求时就建立了连接，此时如果第一次同步请求由于网络通畅到达了，那么就会造成两次建立连接，导致不必要的错误或资源浪费。</li>
<li>能不能三次挥手<br>
不能。需要服务端传输数据的时间。</li>
<li>如果建立连接后客户端故障咋办。<br>
有计数保活器，每次接收到客户端资源都会更新保活器，如果两个小时没接收到，那就发送探测报文端，没75秒发送一个，一连10个都没反应就关闭连接。</li>
<li>如何保证可靠性
<ul>
<li>超时重传：有一个定时器，超时没收到确认码就重新传输。</li>
<li>数据报检验：端对端的检验，防止到达目的IP后，在分用的时候可能会出现问题。</li>
<li>流量控制：通过滑动窗口控制流量</li>
<li>拥塞控制：慢开始（一开始就发送大量数据容易拥塞）、拥塞避免 （拥塞窗口缓慢变大）、快速重传和恢复（一个没确认，但后续三个确认了，就迅速重传没确认那个）</li>
<li>数据包重排序：</li>
<li>停止等待协议：发完一个分组就停止发送，等待对方发送确认码。<br>
<a href="https://blog.csdn.net/guanghuichenshao/article/details/81916277">2-5参考</a></li>
</ul>
</li>
<li>TCP/IP有几层？每一层的作用？MAC地址在哪层？
<ul>
<li>四层：应用层，传输层，网络层，链路层</li>
<li>链路层：物理接口方面的，以太网协议，点对点协议</li>
</ul>
</li>
<li>有什么应用层协议<br>
HTTP、DNS、DHCP、SMTP</li>
<li>IPv4、IPv6
<ul>
<li>长度不同，一个32位一个128位</li>
<li>安全性不同，ipv6可以加密传输</li>
<li>路由表大小不同，IPv6的路由表相比IPv4的更小</li>
<li>IPv6的组播支持以及对流的支持要强于IPv4</li>
<li>IPv6使用NDP，IPv4使用ARP</li>
</ul>
</li>
<li>ARP协议<br>
地址解析协议，先查ARP缓存，然后先匹配网络号和子网号，再匹配默认，广播方式发送局域网。</li>
<li>http状态码<br>
200是请求请求成功，300重定向，400客户端错误，500是服务端错误。</li>
<li>request和response<br>
request发送请求头，包括方法、URI和协议版本，请求字段，请求主体；response中有响应头，包括协议版本，状态码，状态信息，返回头和主体。</li>
</ol>
<h3 id="算法">算法</h3>
<ol>
<li>
<p>数组与链表的区别</p>
<ul>
<li>数组连续存储，链表不连续</li>
<li>数组通过下标访问，链表通过结点存放的地址访问</li>
<li>数组定长，链表不定长</li>
</ul>
</li>
<li>
<p>二分查找过程<br>
取中位数进行比较，然后对</p>
</li>
<li>
<p>二叉树遍历方式，后序过程<br>
前序、中序、后序遍历。</p>
</li>
<li>
<p>快排过程</p>
</li>
<li>
<p>二叉树先序遍历和后序遍历结果相同是什么二叉树<br>
只有一个父节点的树</p>
</li>
<li>
<p>双向链表节点删除</p>
</li>
<li>
<p>单链表给两个指针怎么检验是否有环。快慢指针的方式，</p>
</li>
<li>
<p>堆排序为啥不稳定和建堆时间<br>
自上而下建堆是O(nlogn)，自下而上是O(n)</p>
</li>
<li>
<p>循环队列三种方式</p>
<ul>
<li>设定一个flag，初始化为false，在存的时候为true，取的时候为false</li>
<li>设定一个count值</li>
<li>空出一个值</li>
</ul>
</li>
</ol>
<h3 id="java">Java</h3>
<ol>
<li>面向对象的设计要素
<ul>
<li>封装性</li>
<li>多态性</li>
<li>继承性</li>
</ul>
</li>
<li>设计原则
<ul>
<li>单一职责原则（Single Responsibility Principle）：一个类只负责一项职责</li>
<li>接口隔离原则（Interface Segregation Principle）：一个类对另一个类的依赖应该建立在最小接口上</li>
<li>依赖倒转原则（Dependence Inversion Principle）：高层模块不要依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；面向接口编程</li>
<li>里氏替换原则（Liskov Substitution Principle）：在子类中尽量不要重写父类方法</li>
<li>开闭原则（Open Closed Principle）：对扩展开放，对修改关闭</li>
<li>迪米特法则：对象与对象之间应该保持最少的了解；只和直接朋友（成员变量、返回类型、参数类型）通信，即类方法中不要以陌生对象作为局部变量。</li>
<li>合成复用原则（Composite Reuse Principle）：尽量使用合成或聚合而不是继承。</li>
</ul>
</li>
<li>Java的基本变量有哪些？类型占用字节？<br>
字符型：char。字节大小：2<br>
布尔型：boolean。Java虚拟机规定为4个字节。<br>
整数型：byte、short、int、long。字节大小：1 2 4 8<br>
浮点型：float、double。字节大小：4 8<br>
空类型：void<br>
内部使用：returnAddress</li>
<li>构造函数能被重写吗？能被重载吗？子类的super是重写吗？<br>
能被重载，不能被重写。子类的super不是重写，是调用，必须在构造函数的第一行。</li>
<li>List和Set区别是什么？Set为什么能去重？
<ul>
<li>List能存放重复对象，Set不可以</li>
<li>List有序，Set无序</li>
</ul>
</li>
<li>HashMap底层原理：bucket扩容？k冲突了怎么办？<br>
扩容是通过复制来的，扩容后的大小为2的幂次方，这跟二次hash计算有关系，然后就是进行拷贝。hash冲突了就先检查bin的第一个node中key值是否相等，如果相等就直接返回，否则就检查第一个node的类型，如果是不是TreeNode，那么就按照链表方式查到链尾，然后添加元素，但是这个时候要判断链长是否超过阈值，默认是8，如果超过了，就将该链转为红黑树；如果检查为TreeNode类型，则直接TreeNode添加结点方法。</li>
<li>Volatile用过吗？有什么作用？<br>
使对象具备可见性，即当对volatile对象进行写操作时，会更新到主存中，其他线程的读需要到主内存中进行读取，内在原理是内存屏障，因此也能防止指令重排。</li>
<li>Java内存机制<br>
每个线程有私有栈，方法区存放类（包含静态变量），堆存放对象。</li>
<li>接口和抽象类的区别有哪些？里面变量有什么不同吗？方法有什么不同？
<ul>
<li>类继承一个抽象类，却可以实现多个接口</li>
<li>抽象类方法有默认实现，接口不存在默认实现</li>
<li>抽象类访问修饰符都可以用，接口只能是public</li>
<li>都不可以被实例化</li>
</ul>
</li>
<li>线程的创建方式有哪几种？创建方法说下？
<ul>
<li>继承Thread，重写run方法</li>
<li>实现Callable，重写call方法</li>
<li>实现Runable，重写run方法</li>
</ul>
</li>
<li>String abc = new Stirng(&quot;111&quot;)，新建了几个对象？abc指向哪？<br>
创建了两个对象，一个在常量池中，一个从常量池拷贝到堆中，abc指向堆中String对象。</li>
<li>对象和类的差异</li>
<li>常用设计模式
<ul>
<li>创建者模式
<ul>
<li>简单工厂模式，工厂方法模式</li>
<li>单例模式</li>
</ul>
</li>
<li>结构型模式
<ul>
<li>原型：实现clone</li>
<li>适配器：类适配器，方法适配器</li>
<li>代理模式：静态代理，动态代理</li>
</ul>
</li>
<li>行为者模式
<ul>
<li>策略者（多态）</li>
<li>观察者：注册观察者</li>
<li>责任链模式：ClassLoader？</li>
</ul>
</li>
</ul>
</li>
<li>多态了解</li>
<li>JVM类加载机制
<ul>
<li>（1）加载：查找并装载类型的二进制数据</li>
<li>（2）连接 ：验证（四次class验证），准备（类变量分配内存并初始化），解析（符号引用转为直接引用）</li>
<li>（3）初始化：把类变量初始化为正确的初始值</li>
</ul>
</li>
<li>GC<br>
分代：young、old</li>
<li>字节码</li>
</ol>
<h3 id="操作系统">操作系统</h3>
<p>《深入理解计算机系统》 《Linux内核设计与实现》《深入理解linux内核》《Linux高性能服务器编程》</p>
<ol>
<li>进程间通讯用什么<br>
管道、FIFO、消息队列、信号量、共享内存</li>
<li>进程阻塞是怎么做到的<br>
等锁、IO</li>
<li>多线程是什么</li>
<li>有哪些锁分别解释一下
<ul>
<li>乐观锁：认为数据不会被修改，所以不会加锁，只会在更新数据时做检查，通常使用CAS算法</li>
<li>悲观锁：认为数据会被修改，加锁。</li>
</ul>
</li>
<li>缓存的作用以及缓存替换算法</li>
<li>虚拟文件系统</li>
<li>进程和线程之间的区别
<ul>
<li>进程：线程是CPU调度的最小单元，切换需要把当前进程寄存器中数据存储到PCB中，然后把切换目标进程PCB中的数据赋值到寄存器中。</li>
<li>线程：是进程调度的最小计算单元，共享内存。切换时把当前线程的指令地址指针存放到TCB中，将下个线程TCB中的指令地址指针存放到esp（CPU取值执行所用的寄存器）中</li>
</ul>
</li>
</ol>
<h3 id="数据库">数据库</h3>
<p>《MySQL必知必会》《数据库原理，编程与性能》《Redis设计与实现》</p>
<h4 id="数据库-2">数据库</h4>
<ol>
<li>索引：B树、B+树底层结构，索引失效条件</li>
<li>sql语法</li>
<li>关系型数据库三范式</li>
<li>存储引擎：InnoDB和MyISAM对比</li>
<li>数据库的锁：行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁等等</li>
<li>数据库隔离级别，脏读、不可重复读、幻读</li>
<li>事务的ACID理论</li>
<li>查询优化：explain，慢查询，show profile</li>
<li>分布式：分库分表，读写分离</li>
<li>sql乐观锁悲观锁</li>
</ol>
<h4 id="redis相关">Redis相关</h4>
<p>《Redis设计与实现》</p>
<ol>
<li>Redis 特点</li>
<li>Redis 底层数据结构：跳表，字典</li>
<li>数据淘汰策略</li>
<li>持久化方式：AOF，RDB</li>
<li>哨兵模式</li>
<li>集群同步方式</li>
</ol>
<h3 id="手撕代码">手撕代码</h3>
<ol>
<li>Leetcode石头碰撞问题</li>
<li>将一整数分别转换成对应的二进制、八进制和十六进制形式</li>
<li>将两个分数进行相加并化简成最精简的形式，输入的分数形式为&quot;a / b&quot;(除号两边有空格），a和b为正整数。<a href="https://www.nowcoder.com/discuss/391425?type=post&amp;order=time&amp;pos=&amp;page=1">题目</a></li>
<li>给一个数组找两个数加起来等于给定数</li>
<li>字符串最大连续子串</li>
<li>删除相邻的重复字符。例：acccaef输出为acaef，accaef输出为ef</li>
<li>字符串解码。例：3[a]2[c]输出为aaaccc，3[a2[c]]输出为accaccacc</li>
<li>链表节点初始化</li>
<li>int型数字反向输出(注意溢出问题)</li>
<li>完整实现一个双向链表</li>
<li>用数组实现深度为100的消息队列，入队出队函数</li>
</ol>
<h3 id="机考">机考</h3>
<ol>
<li>方阵旋转</li>
<li>分礼物</li>
<li>编辑距离</li>
</ol>
<h3 id="项目">项目</h3>
<ol>
<li>需求分析</li>
<li>并发访问的处理</li>
<li>UML有哪些模型</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP协议——ICMP]]></title>
        <id>https://blackfish-wu.github.io/post/tcpip-xie-yi-icmp/</id>
        <link href="https://blackfish-wu.github.io/post/tcpip-xie-yi-icmp/">
        </link>
        <updated>2020-03-23T02:37:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-引言">1 引言</h3>
<ul>
<li>ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。</li>
<li>ICMP报文通常被IP层或更高层协议（TCP或UDP）使用。</li>
<li>ICMP报文是在IP数据报内部，在IP数据报的数据部分。<br>
<img src="https://blackfish-wu.github.io//post-images/1584931223410.png" alt="ICMP报文" loading="lazy"></li>
<li>ICMP的正式规范参见RFC 792</li>
<li>ICMP的格式：
<ul>
<li>类型字段有15个值，以描述特定类型的ICMP报文。</li>
<li>代码字段用于某些ICMP报文，用以进一步描述不同的条件。</li>
<li><strong>检验和字段覆盖整个ICMP报文</strong>。使用的算法与IP首部检验和算法相同。<br>
<img src="https://blackfish-wu.github.io//post-images/1585137316500.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>不能产生ICMP差错报文的情况：
<ul>
<li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址或多播地址的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片。</li>
<li>源地址不是单个主机的数据报。源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ul>
</li>
</ul>
<h3 id="2-icmp报文类型">2 ICMP报文类型</h3>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584932928023.png" alt="ICMP报文类型" loading="lazy"></figure>
<ul>
<li>不同类型由报文中的类型字段和代码字段来共同决定。</li>
<li>上图中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。区分的原因是有时需要对ICMP差错报文进行特殊处理，例如在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文。</li>
<li>当发送一份ICMP差错报文时，报文始终包含<strong>产生ICMP差错报文的IP首部和IP数据报的前8个字节</strong>。这样，接收ICMP差错报文的模块就会把它与某个特定的协议和用户进程联系起来。
<ul>
<li>对于其他类型的ICMP<strong>查询</strong>报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。</li>
</ul>
</li>
</ul>
<h3 id="3-ping">3 Ping</h3>
<h4 id="31-ping程序">3.1 Ping程序</h4>
<ul>
<li>我们称发送回显请求的ping程序为客户，而称被ping的主机为服务器。</li>
<li>大多数的TCP/IP实现都在内核中直接支持Ping服务器<br>
<img src="https://blackfish-wu.github.io//post-images/1584967740554.png" alt="回显请求和回显应答报文" loading="lazy"></li>
<li>回显请求和回显应答报文格式如上所示，Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。</li>
<li>序列号从0开始，每发送一次新的回显请求就加1。</li>
<li>ping程序通过在ICMP报文数据中存放发送请求的时间值来计算往返时间。当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间。</li>
</ul>
<h4 id="32-记录路由">3.2 记录路由</h4>
<ul>
<li>记录路由是一个在IP首部设定RR选项的ICMP回显请求报文，每个处理该数据报的路由器都把它的IP<strong>出口</strong>地址放入选项字段中。当数据报到达目的端时，IP地址清单应该复制到ICMP回显应答中，这样返回途中所经过的路由器地址也被加入清单中。</li>
<li>缺陷：
<ul>
<li>不是所有路由都支持该选项功能</li>
<li>P首部中只有有限的空间来存放IP地址。由于IP首部固定长度为20字节， RR选项用去3个字节，这样只剩下37个字节来存放IP地址清单，也就是说只能存放9个IP地址。</li>
</ul>
</li>
<li>IP数据报中的RR选项的一般格式：<br>
<img src="https://blackfish-wu.github.io//post-images/1585214305402.png" alt="" loading="lazy">
<ul>
<li>code是一个字节，指明IP选项的类型。对于RR选项来说，它的值为7。</li>
<li>len是RR选项总字节长度，在这种情况下为39（ping程序总是提供39字节的选项字段，最多可以记录9个IP地址，尽管可以为RR选项设置更小的长度）。</li>
<li>ptr称作指针字段，指向存放下一个IP地址的位置</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP 协议——IP：网际协议]]></title>
        <id>https://blackfish-wu.github.io/post/tcpip-xie-yi-ipwang-ji-xie-yi/</id>
        <link href="https://blackfish-wu.github.io/post/tcpip-xie-yi-ipwang-ji-xie-yi/">
        </link>
        <updated>2020-03-20T09:51:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-引言">1 引言</h3>
<ul>
<li>IP是TCP/IP协议族中最为核心的协议。</li>
<li>所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</li>
<li><strong>不可靠性</strong>，指不能保证IP数据报能成功地到达目的地。任何要求的可靠性必须由上层来提供（如TCP）。</li>
<li><strong>无连接性</strong>，指是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。IP数据报可以不按发送顺序接收。</li>
<li>RFC 791是IP的正式规范文件。</li>
</ul>
<h3 id="2-ip首部">2 IP首部</h3>
<figure data-type="image" tabindex="1"><img src="https://blackfish-wu.github.io//post-images/1584707964621.png" alt="IP数据报格式及首部中的各字段" loading="lazy"></figure>
<ul>
<li>数据报格式如上图，阅读顺序是从左到右，从上到下</li>
<li>前20个字节加上选项部分为IP首部</li>
<li>格式：
<ol>
<li>协议版本号，ipv4时值为4，ipv6值为6</li>
<li>首部长度，是指IP首部所占的字节数除以4的数量（单位：32bit），取值为5-15，即最少20字节，最大60字节。</li>
<li>服务类型，长度为8 bit，其中3 bit为优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位但必须置0。其中，TOS子字段分别表示最小时延、最大吞吐量、最高可靠性和最小费用。TOS子字段只能将其中一个置为1，当都为0时意味着是一般服务。RFC 1349更详细地描述了TOS的特征。</li>
<li>总长度，指整个IP数据报的长度，以字节为单位。由于该字段长16比特，所以IP数据报最大可达65535字节。当数据报被分片后，每个片的总长度值要改为该片的长度值。</li>
<li>标识字段，唯一地标识主机发送的每一份数据报，通常每发送一份报文它的值就会加1。</li>
<li>标志字段，标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1。标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。当需要进行分片但设置了不分片比特时，把数据报丢弃并发送一个ICMP差错报文。</li>
<li>片偏移字段，指的是该片偏移原始数据报开始处的位置。</li>
<li>TTL字段，生存时间字段设置了数据报可以经过的最多路由器数，指定了数据报的生存时间。每经过一个处理它的主机，它的值就减去1，当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>
<li>协议字段，根据它可以识别是哪个协议向IP传送数据。，1表示为ICMP协议， 2表示为IGMP协议， 6表示为TCP协议， 17表示为UDP协议。</li>
<li>首部检验和，检验数据报在传输过程中是否出现差错。将首部每16个bit视为一个二进制表示的数，按每1个bit进行反码求和后，将结果存放在首部校验和字段中。接收方接收后进行反码求和，结果应该全为1，否则丢弃该收到的数据报，但不生成差错报文。</li>
<li>源IP地址和目标IP地址</li>
<li>任选项，是数据报中的一个可变长的可选信息。如安全和处理限制，记录路径等等，很少被使用。选项字段一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节。</li>
</ol>
</li>
</ul>
<h3 id="3-路由选择">3 路由选择</h3>
<h4 id="31-路由表">3.1 路由表</h4>
<ol>
<li>目的IP地址。它既可以是一个完整的主机地址，也可以是一个网络地址。</li>
<li>下一站路由器的IP地址，或者有直接连接的网络IP地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。</li>
<li>标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。</li>
<li>为数据报的传输指定一个网络接口。</li>
</ol>
<h4 id="32-路由选择">3.2 路由选择</h4>
<ol>
<li>搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li>
<li>搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。</li>
<li>搜索路由表，寻找标为“默认（default）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。</li>
<li>如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。</li>
</ol>
<h3 id="4-子网寻址和子网掩码">4 子网寻址和子网掩码</h3>
<h4 id="41-子网寻址">4.1 子网寻址</h4>
<ul>
<li>子网，是指从大网络细分的子网络。因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{24}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{16}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>（全1和全0的主机地址无效）。在InterNIC获得某类I P网络号后，就由当地的系统管理员来进行分配，由他（或她）来决定是否建立子网，以及分配多少比特给子网号和主机号。</li>
<li>大多数的子网例子都是B类地址。其实，子网还可用于C类地址，只是它可用的比特数较少而已。大多数A类地址都是进行子网划分的。</li>
</ul>
<h3 id="42-子网掩码">4.2 子网掩码</h3>
<ul>
<li>子网掩码用来指明一个IP地址的哪些位标识的是主机的网络号和子网号，以及哪些位标识的是主机号。</li>
<li>子网掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</li>
<li>IP地址一般以点分十进制方法表示，但是子网掩码却经常用十六进制来表示。</li>
<li>给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：(1)本子网上的主机；(2)本网络中其他子网中的主机；(3)其他网络上的主机。</li>
<li>如果知道本机的IP地址，那么就知道它是否为A类、B类或C类地址(从IP地址的高位可以得知)，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。</li>
</ul>
<h3 id="5-特殊的ip地址">5 特殊的IP地址</h3>
<figure data-type="image" tabindex="2"><img src="https://blackfish-wu.github.io//post-images/1584800170291.png" alt="" loading="lazy"></figure>
<ul>
<li>上图表示7个特殊的IP地址，0表示所有的比特位全为0；- 1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。</li>
<li>表的头两项是特殊的源地址，中间项是特殊的环回地址，最后四项是广播地址。</li>
<li>表中的头两项，网络号为0，如主机使用BOOTP协议确定本机I P地址时只能作为初始化过程中的源地址出现。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构——图]]></title>
        <id>https://blackfish-wu.github.io/post/shu-ju-jie-gou-tu/</id>
        <link href="https://blackfish-wu.github.io/post/shu-ju-jie-gou-tu/">
        </link>
        <updated>2019-10-07T14:51:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-介绍">1 介绍</h2>
<h3 id="11-定义">1.1 定义</h3>
<ul>
<li>表示“多对多”的关系</li>
<li>包含：
<ol>
<li>一组顶点：通常用V(Vertex)表示顶点集合</li>
<li>一组边：通常用E(Edge)表示边的集合：无向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>)</mo><mo>∈</mo><mi>E</mi><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">(v,w)\in E, 其中 v,w\in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>；有向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v,w&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>表示从v到w的边；不考虑重边和自会路</li>
</ol>
</li>
</ul>
<h3 id="12-常见术语">1.2 常见术语</h3>
<ul>
<li>无向图：所有的边都没有方向的图</li>
<li>有向图：边是有方向的</li>
<li>网络：边带权重的图</li>
<li>度：从顶点发出的边数为“出度”，指向该点的边数为“入度”</li>
<li>连通：如果从V到W存在一条(无向)路径，则称V和W是连通的</li>
<li>路径：V到W的路径是一系列顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>W</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{V, v_1, v_2, ..., v_n, W\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mclose">}</span></span></span></span>的集合，其中任一对相邻的顶点间都有图的边。<strong>路径的长度</strong>是路径中的边数（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同，则称为<strong>简单路径</strong></li>
<li>回路：起点等于终点的路径</li>
<li>连通图：图中任意两顶点均连通</li>
<li>连通分量：无向图的<strong>极大</strong>连通子图，极大表示：①顶点数极大，再加上一个顶点就不连通了。②边数极大，包含子图中的所有顶点相连的所有边。</li>
<li>强连通：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的</li>
<li>强连通图：有向图中任意两个顶点均强连通</li>
<li>强连通分量：有向图中的极大强连通子图</li>
</ul>
<h3 id="13-图的表示">1.3 图的表示</h3>
<h4 id="131-邻接矩阵">1.3.1 邻接矩阵</h4>
<ol>
<li>邻接矩阵G[N][N]——N个顶点从0到N-1编号</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">若</mi><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mi mathvariant="normal">是</mi><mi>G</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">边</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">否</mi><mi mathvariant="normal">则</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">G[i][j]=\begin{cases} 1&amp; 若&lt;v_i,v_j&gt;是G中的边\\ 0&amp; 否则 \end{cases} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">G</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">边</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">则</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ol start="2">
<li>邻接矩阵的特点：
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li>
<li>方便计算任一顶点的“度”</li>
</ul>
</li>
<li>邻接矩阵的缺点：
<ul>
<li>浪费空间————存稀疏图（点很多而边很少）有大量无效元素，但存稠密图（特别是完全图）挺合算</li>
<li>浪费时间————统计稀疏图中一共有多少条边</li>
</ul>
</li>
</ol>
<h4 id="132-邻接表">1.3.2 邻接表</h4>
<ol>
<li>邻接表：G[N]为指针数组，数组的每个元素存放一行链表的头结点，只存非0元素<br>
<img src="https://blackfish-wu.github.io//post-images/1570503578069.png" alt="" loading="lazy"></li>
<li>邻接表的特点：
<ul>
<li>方便找任一顶点中的所有“邻接点”</li>
<li>节约稀疏图的空间（需要N个头指针+2E个结点，E为边数）</li>
<li>方便计算无向图的度和有向图的出度，但不方便计算有向图的入度</li>
</ul>
</li>
<li>邻接表的缺点
<ul>
<li>本身多了一个指针域，表示网络来说，多了一个权重域，所以仅适用于表达稀疏图</li>
<li>不方便计算有向图的入度（除非再构造一个“逆邻接表”）</li>
</ul>
</li>
</ol>
<h3 id="14-图的遍历">1.4 图的遍历</h3>
<h4 id="141-深度优先遍历depth-fisrt-searchdfs">1.4.1 深度优先遍历（Depth Fisrt Search，DFS）</h4>
<pre><code class="language-C">/* 伪代码 */
void DFS(Vertex V){
    visited[V] = true;
    for(V的每个邻接点W)
        if(!visited[W])
            DFS(W);
}
</code></pre>
<ul>
<li>用邻接表存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> (N为结点数，E为边数)</li>
<li>用邻接矩阵存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="142-广度优先遍历breadth-fisrt-searchbfs">1.4.2 广度优先遍历（Breadth Fisrt Search，BFS）</h4>
<pre><code class="language-C">/* 伪代码 */
void BFS(Vertex V){
    visited[V] = true;
    Enqueue(V, Q);
    while(!IsEmpty(Q)){
        V = Dequeue(Q);
        for(V的每个邻接点W){
            if(!visited[W]){
                visited[W] = true;
                Enqueue(V, Q);
            }
        }
    }
}
</code></pre>
<ul>
<li>用邻接表存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> (N为结点数，E为边数)</li>
<li>用邻接矩阵存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="2-最短路径">2 最短路径</h2>
<h3 id="21-定义">2.1 定义</h3>
<ul>
<li>最短路径：在网络中，求两个顶点间的所有路径中，边权值之和最小的那条路径就是这两点间的最短路径。</li>
<li>源点：求最短路径时的起点称之为源点</li>
<li>终点：求最短路径时的终点称之为终点</li>
<li>单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径</li>
<li>多源最短路径问题：求任意两顶点间的最短路径</li>
</ul>
<h3 id="22-方法">2.2 方法</h3>
<h4 id="221-无权图的单源最短路算法">2.2.1 无权图的单源最短路算法</h4>
<pre><code class="language-C">// T = O(|V|+|E|)
void Unweighted( Vertex S ){
    Enqueue(S, Q);
    while(!IsEmpty(Q)){
        V = Dequeue(Q);
        for(V的每个邻接点W){
            if(dist[W]==-1){
                dist[W] = dist[V]+1;
                path[W] = V;
                Enqueue(W, Q);
            }
        }
    }
}
</code></pre>
<h4 id="222-有权图的单源最短路算法dijkstra算法">2.2.2 有权图的单源最短路算法——Dijkstra算法</h4>
<ul>
<li>令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mi mathvariant="normal">源</mi><mi mathvariant="normal">点</mi><mi>s</mi><mo>+</mo><mi mathvariant="normal">已</mi><mi mathvariant="normal">经</mi><mi mathvariant="normal">确</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">短</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">顶</mi><mi mathvariant="normal">点</mi><msub><mi>v</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">S=\{源点s+已经确定了最短路径的顶点v_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord cjk_fallback">源</span><span class="mord cjk_fallback">点</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">短</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li>
<li>对任一未收录的顶点v，定义dist[V]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>s</mi><mo>→</mo><mo>(</mo><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>S</mi><mo>)</mo><mo>→</mo><mi>v</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{s\rightarrow (v_i \in S)\rightarrow v\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">}</span></span></span></span>的最小长度</li>
<li>真正的最短路径只经过S中的顶点</li>
<li>每次从未收录的顶点中选一个dist最小的收录（贪心）：如果采用遍历的方式获得dist最小，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|V|^2+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>；如果采用最小堆的方法建立和获得最小dist，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|V|log(|V|)+|E|log(|V|))=O(|E|log(|V|))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>增加一个v到S，可能影响另外一个w的dist值</li>
</ul>
<pre><code class="language-C">void Dijkstra(Vertex S){
    while(1){
        V = 未收录顶点中dist最小者;
        if(V不存在)
            break;
        collected[V] = true;
        for(V的每个邻接点W){
            if(collected[W] = false){
                if(dist[V]+E&lt;v,w&gt; &lt; dist[W]){
                    dist[W] = dist[V]+E&lt;v,w&gt;;
                    path[W] = V;
                }
            }
        }
    }
}
</code></pre>
<h4 id="223-多源最短路算法floyd算法">2.2.3 多源最短路算法——Floyd算法</h4>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mo>{</mo><mi>i</mi><mo>→</mo><mo>{</mo><mi>l</mi><mo>≤</mo><mi>k</mi><mo>}</mo><mo>→</mo><mi>j</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">D^k[i][j]=路径\{i \rightarrow \{l\le k\}\rightarrow j\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mopen">{</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mn>0</mn></msup><mo separator="true">,</mo><msup><mi>D</mi><mn>1</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>D</mi><mrow><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">D^0, D^1, ..., D^{|v|-1}[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mtight">∣</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>即给出了从0到|v|-1逐次加入顶点后i到j的最短距离矩阵</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>应为带权的邻接矩阵，对角线为0</li>
<li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>已经完成，递推到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">D^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>时：如果新加入的顶点k不影响<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>各个顶点彼此间最短路径，则不需要更新；反之，如果影响了，那么影响后的最短路径必然由两段最短路径组成，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>D</mi><mi>k</mi></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><msup><mi>D</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">D^k[i][j]=D^{k-1}[i][k]+D^{k-1}[k][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Floyd(){
    for(i=0;i&lt;N;i++){
        for(j=0;j&lt;n;j++){
            D[i][j] = G[i][j];
            path[i][j] = -1;
        }
    }
    for(k=0;k&lt;N;k++)
        for(i=0;i&lt;N;i++){
            for(j=0;j&lt;n;j++)
                if(D[i][k]+D[k][j]&lt;D[i][j]){
                    D[i][j] = D[i][k]+D[k][j];
                    path[i][j] = k;
                }
            }
}
</code></pre>
<h2 id="3-最小生成树">3 最小生成树</h2>
<h3 id="31-定义">3.1 定义</h3>
<ul>
<li>是一棵无回路的树，|V|个顶点一定有|V|-1条边</li>
<li>包含了全部的顶点，|V|-1条边都在路里</li>
<li>|V|-1条边的权重和最小</li>
</ul>
<h3 id="32-方法">3.2 方法</h3>
<h4 id="321-prim算法">3.2.1 Prim算法</h4>
<pre><code class="language-C">void Prim(Vertex s){
    MST = {s};
    while(1){
        v = 未收录顶点中dist最小的;
        if(这样的V不存在)
            break;
        将V收录进MST: dist[v] = 0;
        for(v的每个邻接点W){
            if(W未被收录)
                if(E&lt;v,w&gt; &lt; dist[w]){
                    dist[W] = E&lt;v,w&gt;;
                }
        }
    }
}
</code></pre>
<h4 id="322-kruskal算法将森林合并成树">3.2.2 Kruskal算法——将森林合并成树</h4>
<ul>
<li>思路：从图中每次找到边权值最小的边，如果该边不构成回路，则加入到生成树集合；如果构成，删除掉该边</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T=O(|E|log(|E|))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code class="language-C">void Kruskal(Vertex s){
    MST = {};
    while(MST中的边不到|V|-1条&amp;&amp;E中还有边){
        e=E中权重最小的边；            /* 最小堆 */
        Delete(E, e); 
        if(e加入到MST没有构成最小回路)  /* 并查集 */
            e 加入到 MST;
    }
    if( MST中的边不到|V|-1条 )
        Error(&quot;生成树不存在&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OGC的Simple Features Access(ISO 19125)标准]]></title>
        <id>https://blackfish-wu.github.io/post/ogc-de-simple-features-accessiso-19125biao-zhun/</id>
        <link href="https://blackfish-wu.github.io/post/ogc-de-simple-features-accessiso-19125biao-zhun/">
        </link>
        <updated>2019-09-23T12:29:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-简介">1 简介</h2>
<p>OpenGIS定义的Simple Features Access（SFA， ISO 19125）标准的第二部分定义了包含了空间和非空间属性的要素集合的标准SQL模式。这里的要素集是指带地理属性的表。该标准主要包含以下4点：</p>
<ol>
<li>确立了一个表达要素的框架</li>
<li>确立了框架的一系列术语的定义</li>
<li>定义了一个用于定义几何属性的简单几何概述</li>
<li><strong>描述了一系列SQL几何类型及其对应的SQL函数</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ArcGIS10.3 发布要素服务的流程(SQLServer)]]></title>
        <id>https://blackfish-wu.github.io/post/arcgis103-fa-bu-yao-su-fu-wu-de-liu-cheng-sqlserver/</id>
        <link href="https://blackfish-wu.github.io/post/arcgis103-fa-bu-yao-su-fu-wu-de-liu-cheng-sqlserver/">
        </link>
        <updated>2019-08-16T14:02:01.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>创建企业地理数据库<br>
<img src="https://blackfish-wu.github.io//post-images/1565964186616.png" alt="" loading="lazy"></li>
<li>创建数据库连接<br>
<img src="https://blackfish-wu.github.io//post-images/1565964341417.png" alt="" loading="lazy"></li>
<li>将待发布为要素服务的数据导入该数据库中。<br>
<img src="https://blackfish-wu.github.io//post-images/1565964347628.png" alt="" loading="lazy"></li>
<li>右键选择该要素，将其注册为版本化数据<br>
<img src="https://blackfish-wu.github.io//post-images/1565964354123.png" alt="" loading="lazy"></li>
<li>创建arcgis server，账号密码为arcgis server manager登录的账号密码<br>
<img src="https://blackfish-wu.github.io//post-images/1565964371531.png" alt="" loading="lazy"></li>
<li>打开服务属性。<br>
<img src="https://blackfish-wu.github.io//post-images/1565964378603.png" alt="" loading="lazy"></li>
<li>为服务配置数据库连接属性。在选择“是否跟发布的数据库连接相同连接（same as pubilisher database connection）”选项时，应注意arcgis server服务登录的账号是否为本地账户（打开“运行”，输入services.msc，找到arcgis server 服务，右键属性，打开登录标签，查看是否为本地系统账户），如果是就勾选。<br>
<img src="https://blackfish-wu.github.io//post-images/1565964387856.png" alt="" loading="lazy"></li>
<li>将放置到SDE的图层加载到ArcMap上，选择share as service，勾选要素服务进行发布。</li>
<li>打开manager， 查看服务是否能正常开启。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python环境中使Arcpy]]></title>
        <id>https://blackfish-wu.github.io/post/python-huan-jing-zhong-shi-yong-arcpy/</id>
        <link href="https://blackfish-wu.github.io/post/python-huan-jing-zhong-shi-yong-arcpy/">
        </link>
        <updated>2019-08-16T09:33:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="手动添加依赖">手动添加依赖</h4>
<p>在import arcpy之前添加相关的包路径到sys.path即可，<strong>路径以本机安装ArcGIS的路径和版本为准</strong></p>
<pre><code class="language-Python">import sys
sys.path.append(&quot;C:\Python27\ArcGIS10.5\Lib\site-packages&quot;)
sys.path.append(&quot;D:\Software\ArcGIS\Desktop10.5\arcpy&quot;)
sys.path.append(&quot;D:\Software\ArcGIS\Desktop10.5\ArcToolbox\Scripts&quot;)
sys.path.append(&quot;D:\Software\ArcGIS\Desktop10.5\bin&quot;)
sys.path.append(&quot;C:\Python27\ArcGIS10.5\Lib&quot;)
</code></pre>
<h4 id="非手动方式">非手动方式</h4>
<p>每次用到arcpy均要添加相关包有些麻烦。为了避免这种情况，可以直接在[python根目录]\Lib\site-packages下添加一个后缀为.pth的文件，使用记事本打开并添加相关路径，例如：</p>
<pre><code># [python根目录]\Lib\site-packages\arcpy.pth

C:\Python27\ArcGIS10.5\Lib\site-packages
D:\Software\ArcGIS\Desktop10.5\arcpy
D:\Software\ArcGIS\Desktop10.5\ArcToolbox\Scripts
D:\Software\ArcGIS\Desktop10.5\bin
C:\Python27\ArcGIS10.5\Lib
</code></pre>
<h4 id="出错原因">出错原因</h4>
<ol>
<li>DLL %1......：配置的Python环境和ArcGIS使用的Python不是一个C++编辑器编译的，ArcGIS使用的是2.7的32位版本</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://blackfish-wu.github.io/post/hello-gridea/</id>
        <link href="https://blackfish-wu.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>